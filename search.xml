<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Android文件格式</title>
    <url>/2022/10/25/android_file_format/</url>
    <content><![CDATA[<p>本文记录Android中的一些文件格式</p>
<blockquote>
<p>Dalvik虚拟机源码用到的分析Android源码版本：android-4.4w_r1<br>Art 虚拟机源码用到的源码版本：android_10_0_0_r47</p>
</blockquote>
<h2 id="APK"><a href="#APK" class="headerlink" title="APK"></a>APK</h2><p>apk文件包是Android开发中的安装包文件</p>
<h3 id="APK文件结构"><a href="#APK文件结构" class="headerlink" title="APK文件结构"></a>APK文件结构</h3><p>以<a href="app-debug.apk">app-debug.apk</a>为参考解压apk文件查看基础结构如下：</p>
<img data-src="/2022/10/25/android_file_format/Snipaste_2022-10-25_15-45-39.png" class="">

<ul>
<li>classes.dex：可执行代码，如果开启MultiDex，会有多个dex文件</li>
<li>res目录：使用到的资源文件</li>
<li>resources.arsc：编译好的二进制资源文件</li>
<li>AndroidManifest.xml：AXML二进制格式文件，清单配置文件</li>
<li>assets目录：不会编译的资源文件目录</li>
<li>META-INF：保存APK的签名信息</li>
</ul>
<h3 id="APK的生成流程"><a href="#APK的生成流程" class="headerlink" title="APK的生成流程"></a>APK的生成流程</h3><p>下图为AndroidStudio最新的APK生成流程图</p>
<div style="width:50%;margin:auto"><img data-src="/2022/10/25/android_file_format/Snipaste_2022-10-25_16-26-01.png" class=""></div>
总结起来如下：
 编译文件：
  * Java/aidl文件转换为class文件：目录在/app/build/intermediates/javac/下面，主要使用到的命令为javac
  * 资源文件：存在APP的res目录下的资源文件使用aapt工具，生成R.java，并且生成一个resource.arsc形成一个索引表，通过resource id访问
* 生成Dex文件：使用dx工具将class文件转换为dex文件
* 打包生成APK：通过apkbuilder工具将所有的文件打包到apk中
* 签名对齐APK：对应于进行签名并进行对齐操作，主要用到zipalign工具。对齐是将APK包中的所有资源距离文件起始偏移4字节，这样通过内存映射访问apk文件速度会更快，减少运行时内存的使用。

<h3 id="APK的安装过程"><a href="#APK的安装过程" class="headerlink" title="APK的安装过程"></a>APK的安装过程</h3><p>列举出如下四种APK安装方式</p>
<h4 id="系统开机时安装"><a href="#系统开机时安装" class="headerlink" title="系统开机时安装"></a>系统开机时安装</h4><p>由PackageManagerService服务完成。这个服务在启动的时候会扫描&#x2F;system&#x2F;app下的apk重新安装</p>
<h4 id="Android市场应用安装"><a href="#Android市场应用安装" class="headerlink" title="Android市场应用安装"></a>Android市场应用安装</h4><p>国外有Play商店，国内每个产商有自己的市场app。应用商店app如果在&#x2F;system&#x2F;app下，安装过程可以自动完成；否则会弹出软件安全相关的界面，引导安装</p>
<h4 id="通过adb命令安装"><a href="#通过adb命令安装" class="headerlink" title="通过adb命令安装"></a>通过adb命令安装</h4><p>使用adb工具执行adb install xxx.apk 可以自动完成安装</p>
<h4 id="通过SD卡的APK文件安装"><a href="#通过SD卡的APK文件安装" class="headerlink" title="通过SD卡的APK文件安装"></a>通过SD卡的APK文件安装</h4><p>把apk文件放到手机SD卡下，点击apk文件使用系统的packageinstaller.apk来进行安装。我使用的是android_10_0_0_r47,这个apk的源文件位于&#x2F;frameworks&#x2F;base&#x2F;&#x2F;packages&#x2F;PackageInstaller目录下。主界面为PackageInstallerActivity.java</p>
<h2 id="classes-dex"><a href="#classes-dex" class="headerlink" title="classes.dex"></a>classes.dex</h2><p>classes.dex中包含APK的可执行代码</p>
<h3 id="DEX文件结构"><a href="#DEX文件结构" class="headerlink" title="DEX文件结构"></a>DEX文件结构</h3><h4 id="DEX文件头"><a href="#DEX文件头" class="headerlink" title="DEX文件头"></a>DEX文件头</h4><h5 id="DEX文件头定义"><a href="#DEX文件头定义" class="headerlink" title="DEX文件头定义"></a>DEX文件头定义</h5><p>在Android源码art虚拟机对应DEX文件头android_10_0_0_r47的<a href="https://cs.android.com/android/platform/superproject/+/android-10.0.0_r47:art/libdexfile/dex/dex_file.h">art&#x2F;libdexfile&#x2F;dex&#x2F;dexfile.h</a>中，可以看到DEX文件的文件头定义。下面列出dexfile.h中定义DEX文件文件头的数据解释<font color=red>对应Dalvik虚拟机的<a href="https://cs.android.com/android/platform/superproject/+/android-4.4w_r1:dalvik/libdex/DexFile.h">libdex&#x2F;DexFile.h</a> </font>：</p>
<p>这里注意一点：Andoid 4之前使用的是Dalvik虚拟机，所以上面的DexFile.h只能在Android4或以下的版本找到，Android4以上使用的art虚拟机，但是对于dex的一些固定格式是没有变化的，只是各自封装写法有一些差异。</p>
<div class="highlight-wrap" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">// Raw header_item.</span><br><span class="line">  struct Header &#123;</span><br><span class="line">    uint8_t magic_[8] = &#123;&#125;;  				   // 包含了 dex 文件标识符以及版本，从 0x00 开始，长度为 8 个字节 </span><br><span class="line">    uint32_t checksum_ = 0;  				   // dex 文件校验码，偏移量为: 0x08，长度为 4 个字节</span><br><span class="line">    uint8_t signature_[kSha1DigestSize] = &#123;&#125;;  // dex sha-1 签名，偏移量为 0x0c, 长度为 20 个字节</span><br><span class="line">    uint32_t file_size_ = 0;  				   // dex 文件大小，偏移量为 0x20，长度为 4 个字节 </span><br><span class="line">    uint32_t header_size_ = 0;  			   // dex 文件头大小，偏移量为 0x24，长度为 4 个字节，一般为 0x70 </span><br><span class="line">    uint32_t endian_tag_ = 0;				   // dex 文件判断字节序是否交换，偏移量为 0x28，长度为 4 个字节，一般情况下为 0x78563412 </span><br><span class="line">    uint32_t link_size_ = 0;  				   // dex 文件链接段大小，为 0 则表示为静态链接，偏移量为 0x2c，长度为 4 个字节</span><br><span class="line">    uint32_t link_off_ = 0;  				   // dex 文件链接段偏移位置，偏移量为 0x30，长度为 4 个字节 </span><br><span class="line">    uint32_t map_off_ = 0;  				   // dex 文件中 map 数据段偏移位置，偏移位置为 0x34，长度为 4 个字节 </span><br><span class="line">    uint32_t string_ids_size_ = 0;  		   // dex 文件包含的字符串数量，偏移量为 0x38，长度为 4 个字节 </span><br><span class="line">    uint32_t string_ids_off_ = 0;  			   // dex 文件字符串开始偏移位置，偏移量为 0x3c，长度为 4 个字节</span><br><span class="line">    uint32_t type_ids_size_ = 0;  			   // dex 文件类数量，不超过65525，偏移量为 0x40，长度为 4 个字节</span><br><span class="line">    uint32_t type_ids_off_ = 0;  			   // dex 文件类偏移位置，偏移量为 0x44，长度为 4 个字节 </span><br><span class="line">    uint32_t proto_ids_size_ = 0;  			   // dex 文件中方法原型数量，不超过65535，偏移量为 0x48，长度为 4 个字节</span><br><span class="line">    uint32_t proto_ids_off_ = 0;  			   // dex 文件中方法原型偏移位置，偏移量为 0x4c，长度为 4 个字节</span><br><span class="line">    uint32_t field_ids_size_ = 0;  			   // dex 文件中字段数量，偏移量为 0x50，长度为 4 个字节 </span><br><span class="line">    uint32_t field_ids_off_ = 0;  			   // dex 文件中字段偏移位置，偏移量为 0x54，长度为 4 个字节</span><br><span class="line">    uint32_t method_ids_size_ = 0;  		   // dex 文件中方法数量，偏移量为 0x58，长度为 4 个字节 </span><br><span class="line">    uint32_t method_ids_off_ = 0;  			   // dex 文件中方法偏移位置，偏移量为 0x5c，长度为 4 个字节 </span><br><span class="line">    uint32_t class_defs_size_ = 0;  		   // dex 文件中类定义数量，偏移量为 0x60，长度为 4 个字节 </span><br><span class="line">    uint32_t class_defs_off_ = 0;  			   // dex 文件中类定义偏移位置，偏移量为 0x64，长度为 4 个字节</span><br><span class="line">    uint32_t data_size_ = 0;  				   // dex 数据段大小，偏移量为 0x68，长度为 4 个字节 </span><br><span class="line">    uint32_t data_off_ = 0;  				   // dex 数据段偏移位置，偏移量为 0x6c，长度为 4 个字节</span><br><span class="line"></span><br><span class="line">    // Decode the dex magic version</span><br><span class="line">    uint32_t GetVersion() const;</span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure></div>

<h5 id="DEX文件头解析"><a href="#DEX文件头解析" class="headerlink" title="DEX文件头解析"></a>DEX文件头解析</h5><p>还是以这个<a href="apk-debug.apk">apk-debug.apk</a>里面的classes.dex文件来查看解析这个DEX里面的信息，提取出里面的DEX文件，使用apktool禁止将dex文件转换为smali：</p>
<div class="highlight-wrap" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">apktool d -s app-debug.apk</span><br></pre></td></tr></table></figure></div>
</br>
我们使用010Editor来查看反编译出来的[classes.dex](classes.dex.bak)文件，找找是否有上面看到的头信息相关的东西：
<div style="width:50%;margin:auto"><img data-src="/2022/10/25/android_file_format/Snipaste_2022-10-27_15-38-43.png" class=""></div>

<p>可以看到开头的8个字节为16进制：64 65 78 0A 30 33 35 00<br>使用网站<a href="https://www.bejson.com/convert/ox2str/">bejson</a>把16进制转为字符看到如下结果：</p>
<div style="width:50%;margin:auto"><img data-src="/2022/10/25/android_file_format/Snipaste_2022-10-27_15-51-14.png" class=""></div>

<p><strong>符合看到的第一个magic字段，表示dex文件标识和035版本</strong></p>
<p>DEX文件里面的每个header字段像是一个字典，它列出了DEX文件的整体目录结构，我们可以解析这个文件相应的字段，来获取DEX里面的主要信息，例如checksum字段是DEX文件的校验和，我们可以通过它来判断DEX文件是否已经损坏或篡改，在做应用安全的时候可以对这个进行验证。分享一篇文章列出DEX文件的解析以及字段的简单介绍：<br><a href="https://cloud.tencent.com/developer/article/1663852">一文读懂 DEX 文件格式解析</a>，可以参考写的pythone脚本列出DEX文件里面的字段解析</p>
<p>还有一个比较便利的查看dex文件中的内容：使用010Editor下载解析查看Dex的模板，如图安装在线模板，然后重新打开Dex文件：</p>
<div style="width:50%;margin:auto"><img data-src="/2022/10/25/android_file_format/Snipaste_2022-10-27_16-26-45.png" class=""></div>

<p>重新打开classes.dex文件查看得到如下：</p>
<div style="width:50%;margin:auto"><img data-src="/2022/10/25/android_file_format/Snipaste_2022-10-27_16-28-59.png" class=""></div>

<p>这个查看16进制文件的工具不愧是神器！！</p>
<h3 id="DEX文件的验证与优化流程"><a href="#DEX文件的验证与优化流程" class="headerlink" title="DEX文件的验证与优化流程"></a>DEX文件的验证与优化流程</h3><p>Dalvik虚拟机使用dexopt工具来做验证和优化工作，源码入口位于<a href="https://cs.android.com/android/platform/superproject/+/android-4.4w_r1:dalvik/dexopt/OptMain.cpp">android-4.4w_r1:dalvik&#x2F;dexopt&#x2F;OptMain.cpp</a><br>详细的源码流程待后续有需要可查看。</p>
<p>验证主要是验证DEX中的checksum和signature字段的信息<br>优化主要是进行指令替换，替换的优先级为：volatile替换最高，正确性替换其次，高性能替换最低。</p>
<h3 id="DEX文件修改"><a href="#DEX文件修改" class="headerlink" title="DEX文件修改"></a>DEX文件修改</h3><p>之前的分析文章<a href="https://lymanye.github.io/2022/10/16/analysis-of-android-program-decompile-and-resignature/#more">Android 程序分析 &amp; 反编译重签名</a> 了解了破解的一般步骤，是通过修改smali代码指令，然后重新生成apk签名的，有一种方法，直接修改classes.dex的16进制文件，然后根据上面了解的重新生成checksum和signature信息，也可以实现破解。使用<a href="https://www.newasp.com/soft/346032.html">IDA Pro</a>工具来修改16进制文件，它可以找到破解点对应的文件偏移。使用这个软件进行如下步骤操作，此软件的详细使用后续再熟悉</p>
<ul>
<li>查看解包目录下的&#x2F;app-debug&#x2F;res&#x2F;values&#x2F;public.xml搜索unsuccessed得到id为0x7f0d0028<img data-src="/2022/10/25/android_file_format/Snipaste_2022-10-29_10-34-39.png" class=""></li>
<li>IDA pro使用alt+T弹出搜索框搜索0x7f0d0028<img data-src="/2022/10/25/android_file_format/Snipaste_2022-10-29_10-36-15.png" class=""></li>
</ul>
<p>得到如下搜索结果：</p>
<div style="width:50%;margin:auto"><img data-src="/2022/10/25/android_file_format/Snipaste_2022-10-29_11-06-47.png" class=""></div>
双击第一个在onClick函数里面的内容，得到如下结果
<div style="width:50%;margin:auto"><img data-src="/2022/10/25/android_file_format/Snipaste_2022-10-29_11-07-31.png" class=""></div>
大概可以看出是if-nez这个语句的两个case分支，选中if-nez跳到Hex View-1 的Tab
<div style="width:50%;margin:auto"><img data-src="/2022/10/25/android_file_format/Snipaste_2022-10-29_11-09-51.png" class=""></div>
其中39为if-nez指令的opcode,把这个改为相反的if-eqz也就是指令38
* 保存修改内容
IDA Pro从6.8版本支持补丁修改内容，点击Edit->Patch Program-> Change byte
修改指令39为38。修改后点击Edit->Patch Program->Apply patches to input file

<ul>
<li><p>修改checksum和signature<br>修改了的dex的checksum和signature需要变更，不然虚拟机验证的时候会不通过。<br>有两种方法修改这个</p>
<ul>
<li><p>使用010Editor应用如下<a href="DexFixer.lsc">DexFixer.lsc</a>脚本，可以完成修改.修改后的checksum和signature如下：</p>
<div style="width:50%;margin:auto"><img data-src="/2022/10/25/android_file_format/Snipaste_2022-10-29_11-35-32.png" class=""></div>
</li>
<li><p>使用<a href="dex2jar-2.1.zip">dex2jar-2.1.zip</a>提供的d2j-dex-recompute-checksum.执行如下命令：</p>
<div class="highlight-wrap" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">d2j-dex-recompute-checksum -f ./classes.dex</span><br></pre></td></tr></table></figure></div>
</br>
得到classes-rechecksum.dex把这个dex放到010Editor查看checksum和signature
<div style="width:50%;margin:auto"><img data-src="/2022/10/25/android_file_format/Snipaste_2022-10-29_11-41-23.png" class=""></div>
和我们上面的脚本运行的一样，ok修改完毕</li>
</ul>
</li>
<li><p>验证apk<br>重新得到验证的classes.dex放到app-debug目录中替换原有的classes.dex</p>
<p>回编apk</p>
</li>
</ul>
<div class="highlight-wrap" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">apktool b app-debug</span><br></pre></td></tr></table></figure></div>
</br>
从目录获取/app-debug/dist/app-debug.apk做签名安装即可(注意各版本Android v1，v2签名的东西)，签名可以看这篇文章：[Android 程序分析 & 反编译重签名](https://lymanye.github.io/2022/10/16/analysis-of-android-program-decompile-and-resignature/)

<h3 id="MultiDex"><a href="#MultiDex" class="headerlink" title="MultiDex"></a>MultiDex</h3><p>Dex分包技术。DEX中包含的方法数不能超过64KB，但是应用可能不止使用这么多方法，于是有这个技术的使用场景。新的Apktool已经支持对多个dex文件的apk进行反编译了。</p>
<h2 id="AndroidManifest-xml"><a href="#AndroidManifest-xml" class="headerlink" title="AndroidManifest.xml"></a>AndroidManifest.xml</h2><p>AndroidManifest.xml才有XML文本格式，包含软件的名称，图标，主题，包名，组件配置等信息。</p>
<h3 id="AXML"><a href="#AXML" class="headerlink" title="AXML"></a>AXML</h3><h4 id="AXML文件格式"><a href="#AXML文件格式" class="headerlink" title="AXML文件格式"></a>AXML文件格式</h4><p>AndroidStudio编译APK的时候，会将AndroidManifest.xml处理打包进去。打包进的AndroidManifest.xml被编译成二进制格式的文件。直接解压apk文件，查看这个文件是乱码的，不能正常显示。打包后的AndroidManifest.xml称为AXML，它的格式称为AXML格式</p>
<p>010Editor可以安装AXML文件文件格式模板，我们使用直接解压我们文章中的apk里面的<a href="AndroidManifest.xml">AndroidManifest.xml</a>,通过在010安装模板看看：</p>
<ul>
<li>安装AndroidManifest.bt在线模板<div style="width:50%;margin:auto"><img data-src="/2022/10/25/android_file_format/Snipaste_2022-10-29_14-45-14.png" class=""></div></li>
<li>点击查看HEX十六进制文件格式<div style="width:50%;margin:auto"><img data-src="/2022/10/25/android_file_format/Snipaste_2022-10-29_14-48-30.png" class=""></div></li>
<li>应用第一步下好的模板<div style="width:50%;margin:auto"><img data-src="/2022/10/25/android_file_format/Snipaste_2022-10-29_14-49-34.png" class=""></div></li>
<li>查看AndroidManifest.xml的文件结果<div style="width:50%;margin:auto"><img data-src="/2022/10/25/android_file_format/Snipaste_2022-10-29_14-50-48.png" class=""></div></li>
</ul>
<p>AXML的文件结构提供参考解析文章：<a href="https://blog.csdn.net/beyond702/article/details/51830108">手把手教你解析AXML</a></p>
<h4 id="AXML文件的修改"><a href="#AXML文件的修改" class="headerlink" title="AXML文件的修改"></a>AXML文件的修改</h4><p>有些APK加固后无法使用Apktool来反编译，有可能是构造了一个畸形的AndroidManifest.xml，安装是可以安装应用，解析会出现问题，这个时候可能要修改AXML文件。</p>
<ul>
<li>配合010Editor以AXML模板查看文件格式，找到异常来修改</li>
<li>使用工具来修改：<a href="https://github.com/ele7enxxh/AmBinaryEditor">AmBinaryEditor</a> , <a href="https://github.com/zylc369/AndroidManifestFix">AndroidManifestFix</a></li>
</ul>
<h2 id="resources-arsc"><a href="#resources-arsc" class="headerlink" title="resources.arsc"></a>resources.arsc</h2><p>这个文件存放了应用所有资源文件对应的Id,名字等信息。应用的png,jpg图片原样放到&#x2F;res目录下面，layout,drawalbe,color这些安装AXML文件格式存放。Java层的R.java是连接这些资源的桥梁，通过编译器自动生成。</p>
<h3 id="ARSC文件格式"><a href="#ARSC文件格式" class="headerlink" title="ARSC文件格式"></a>ARSC文件格式</h3><p>apk中只有resource.arsc使用了这种格式，同样我们可以通过010Editor的AndroidResource.bt在线模板解析这个格式文件。</p>
<ul>
<li>安装AndroidResource.bt<div style="width:50%;margin:auto"><img data-src="/2022/10/25/android_file_format/Snipaste_2022-10-29_15-09-26.png" class=""></div></li>
<li>导入<a href="resource.arsc">resource.arsc</a>到010Editor软件,查看文件结构<div style="width:50%;margin:auto"><img data-src="/2022/10/25/android_file_format/Snipaste_2022-10-29_15-11-21.png" class=""></div></li>
</ul>
<p>详细arsc文件格式参考：<a href="https://cloud.tencent.com/developer/article/1870342">ARSC 文件格式解析</a></p>
<h3 id="ARSC文件修改"><a href="#ARSC文件修改" class="headerlink" title="ARSC文件修改"></a>ARSC文件修改</h3><p>修改arsc文件的目的</p>
<ul>
<li>阻止或修正APK的反编译，特殊处理的arsc可以正常加载，但是apktool会无法反编译出来</li>
<li>修改arsc里的string资源</li>
</ul>
<p>修改的方法</p>
<ul>
<li>还是使用010Editor查看修改</li>
<li><a href="https://github.com/MrIkso/ArscEditor">ArscEditor</a>工具修改</li>
</ul>
<h2 id="META-INF目录"><a href="#META-INF目录" class="headerlink" title="META-INF目录"></a>META-INF目录</h2><p>这个目录存储一些和APK签名有关的信息</p>
<img data-src="/2022/10/25/android_file_format/Snipaste_2022-10-29_15-21-00.png" class="">

<h3 id="CERT-RSA"><a href="#CERT-RSA" class="headerlink" title="CERT.RSA"></a>CERT.RSA</h3><p>存放的是开发者证书与签名信息。改文件可以识别开发者的身份，以及判断APK是否被篡改。CERT.RSA是由DER编码的证书。由于DER使用了ASN1编码，任何使用ASN1解码库都能对其解码。例如使用openssl提供的解码功能查看CERT.RSA的内容。</p>
<blockquote>
<p>运行环境Ubuntu</p>
</blockquote>
<ul>
<li><p>安装openssl</p>
<div class="highlight-wrap" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt-get install openssl</span><br></pre></td></tr></table></figure></div>
</br>
查看openssl version
<div class="highlight-wrap" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">openssl version     </span><br><span class="line">OpenSSL 1.1.1q  5 Jul 2022</span><br></pre></td></tr></table></figure></div>
</br>
</li>
<li><p>查看证书信息</p>
</li>
</ul>
<div class="highlight-wrap" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">openssl pkcs7 -inform DER -<span class="keyword">in</span> CERT.RSA -noout -print-certs -text</span><br></pre></td></tr></table></figure></div>
</br>

<p>执行报如下错误，暂未找到原因，有知道的麻烦留言告知下：</p>
<div class="highlight-wrap" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">openssl pkcs7 -inform DER -<span class="keyword">in</span> CERT.RSA -noout -print-certs -text</span><br><span class="line">pkcs7: Option unknown option -print-certs</span><br><span class="line">pkcs7: Use -<span class="built_in">help</span> <span class="keyword">for</span> summary.</span><br></pre></td></tr></table></figure></div>
<ul>
<li>使用keytool查看CERT.RSA<div class="highlight-wrap" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">keytool -printcert -file CERT.RSA</span><br></pre></td></tr></table></figure></div>
</br>
得到如下证书信息，是我们之前创建的证书：
<div style="width:50%;margin:auto"><img data-src="/2022/10/25/android_file_format/Snipaste_2022-10-29_16-10-11.png" class=""></div></li>
</ul>
<h3 id="MANIFEST-MF"><a href="#MANIFEST-MF" class="headerlink" title="MANIFEST.MF"></a>MANIFEST.MF</h3><p>它是一个文本文件，可以直接打开查看，是签名的清单文件。</p>
<div style="width:50%;margin:auto"><img data-src="/2022/10/25/android_file_format/Snipaste_2022-10-29_16-13-19.png" class=""></div>
可以看到它是由SignApk创建，v1签名。里面存储的是文件的SHA-1散列值的Base64值

<h3 id="CERT-SF"><a href="#CERT-SF" class="headerlink" title="CERT.SF"></a>CERT.SF</h3><p>签名信息文件，它是一个文本文件。</p>
<div style="width:50%;margin:auto"><img data-src="/2022/10/25/android_file_format/Snipaste_2022-10-29_16-17-53.png" class=""></div>

<p>其中SHA1-Digest-Manifest的值是对MANIFEST.MF的内容的SHA-1散列值进行base64计算得到的结果</p>
<h2 id="ODEX文件"><a href="#ODEX文件" class="headerlink" title="ODEX文件"></a>ODEX文件</h2><p>odex是优化版的dex。<br>在Android N之前，Dalvik虚拟机执行程序dex文件前，系统会对dex文件做优化，生成可执行文件odex，保存到data&#x2F;dalvik-cache目录，最后把apk文件中的dex文件删除。这里不做详细的记录了是Android N之前的一套玩法</p>
<h2 id="OAT"><a href="#OAT" class="headerlink" title="OAT"></a>OAT</h2><p>oat 文件是 ART虚拟机运行的文件，是一种ELF格式的二进制可运行文件，包含 DEX 文件和编译出的本地机器指令文件。因为oat文件包含DEX文件，因此比ODEX文件占用空间更大。</p>
<p>由于其在安装时打包在里面的classes.dex文件会被工具dex2oat翻译成本地机器指令，最终得到一个ELF格式的OAT文件，ART加载OAT文件后不需要经过处理就可以直接运行，它没有了从字节码装换成机器码的过程，因此运行速度更快。</p>
<p>dex2oat与dexopt不同，dex2oat更像一个编译器，将DEX中的Dalvik字节码翻译成Native机器码。</p>
<h3 id="oat生成"><a href="#oat生成" class="headerlink" title="oat生成"></a>oat生成</h3><p>生成看网上说是通过调用手机的&#x2F;system&#x2F;bin&#x2F;dex2oat来执行的，具体的流程还是得啃源码，后续有这部分需要再细读</p>
<h3 id="oat文件格式"><a href="#oat文件格式" class="headerlink" title="oat文件格式"></a>oat文件格式</h3><p><a href="https://my.oschina.net/ososchina/blog/4818362">OAT 文件</a></p>
<h3 id="oat转换为Dex"><a href="#oat转换为Dex" class="headerlink" title="oat转换为Dex"></a>oat转换为Dex</h3><p>oat里面包含了dex文件把它提取出来，通过使用oatdump可以提取出oat里面的dex文件。我这边没有可root的机器，没有搞到oat文件，暂时不实际操作这些部分的内容。</p>
<p>也可以通过010Editor添加这个<a href="Oat2Dex.1sc">oat2dex</a>的脚本进行转换</p>
]]></content>
      <categories>
        <category>Android</category>
        <category>逆向</category>
        <category>《Android软件安全权威指南》实践笔记</category>
      </categories>
      <tags>
        <tag>Android逆向</tag>
      </tags>
  </entry>
  <entry>
    <title>Android程序分析&amp;反编译重签名</title>
    <url>/2022/10/16/analysis-of-android-program-decompile-and-resignature/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>此系列为读《Android软件安全权威指南》学习笔记以及自己的一些实践心得体会记录</p>
<h2 id="实践环境"><a href="#实践环境" class="headerlink" title="实践环境"></a>实践环境</h2><blockquote>
<p><strong>操作系统</strong>： Windows</p>
</blockquote>
<h2 id="常用逆向分析工具"><a href="#常用逆向分析工具" class="headerlink" title="常用逆向分析工具"></a>常用逆向分析工具</h2><p><a href="https://bitbucket.org/JesusFreke/smali/downloads/">backsmail</a>: DEX文件的反编译与回编译工具，提供了smail语法格式，使DEX文件的修改可以基于smail汇编指令完成。ApkTool底层就是使用它提供的dexlib库来生成smail反汇编文件的</p>
<p><a href="">dex2jar</a>:DEX文件转换成jar工具，对使用dex2jar转换的jar包，可以通过jd-gui等工具查看Java代码。</p>
<p><a href="https://www.sweetscape.com/010editor/">010Editor</a>: 是一款专业的文本和十六进制编辑器，其旨在快速轻松地编辑计算机上任何文件的内容.在逆向分析场景中，可以使用此软件内置的脚本语言编写二进制文件格式模板，进行文件格式的分析与测试。</p>
<h2 id="搭建源码分析环境"><a href="#搭建源码分析环境" class="headerlink" title="搭建源码分析环境"></a>搭建源码分析环境</h2><p>在逆向分析场景中，需要分析Android系统源码，例如：</p>
<ul>
<li>测试最新的Android源码刷入自己的rom</li>
<li>定制Android系统，打造专属脱壳工具</li>
<li>编译Android内核并刷机，来绕过反调试</li>
<li>动态调试Android系统源码<br>目前我这边比较方便的是使用Windows10系统来编译，其他系统环境有需要后续补充</li>
</ul>
<h3 id="Window10-Android源码编译"><a href="#Window10-Android源码编译" class="headerlink" title="Window10 Android源码编译"></a>Window10 Android源码编译</h3><p>Windows系统默认不支持源码编译，只有Linux和Mac上支持编译，所以Windows要有Linux或者Ubuntu的系统环境，这里使用DockerDestop For Windows来搞定系统环境，可以粗略理解为它是一个这些环境工具的大集成软件<br><a href="https://zhuanlan.zhihu.com/p/302961875">安装介绍文档参考</a><br><a href="https://blog.51cto.com/u_15060464/3872849">Windows docker镜像位置修改</a><br><a href="https://www.bilibili.com/read/cv10164178">实战Ubuntu20编译Android8.0系统源码</a></p>
<h2 id="破解第一个Android程序"><a href="#破解第一个Android程序" class="headerlink" title="破解第一个Android程序"></a>破解第一个Android程序</h2><p>本文使用到的Android项目源码<a href="Crackme0201.7z">Crackme0201</a><br>整体代码如下：</p>
<div class="highlight-wrap" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">public class MainActivity extends AppCompatActivity &#123;</span><br><span class="line">private EditText edit_userName;</span><br><span class="line">private EditText edit_sn;</span><br><span class="line">private Button btn_register;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void onCreate(Bundle savedInstanceState) &#123;</span><br><span class="line">    super.onCreate(savedInstanceState);</span><br><span class="line">    setContentView(R.layout.activity_main);</span><br><span class="line">    setTitle(R.string.unregister);</span><br><span class="line">    edit_userName = (EditText) findViewById(R.id.edit_username);</span><br><span class="line">    edit_sn = (EditText) findViewById(R.id.edit_sn);</span><br><span class="line">    btn_register = (Button) findViewById(R.id.button_register);</span><br><span class="line">    btn_register.setOnClickListener(new <span class="function"><span class="title">OnClickListener</span></span>() &#123;</span><br><span class="line"></span><br><span class="line">        public void onClick(View v) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!checkSN(edit_userName.getText().toString().trim(),</span><br><span class="line">                    edit_sn.getText().toString().trim())) &#123;</span><br><span class="line">                Toast.makeText(MainActivity.this,</span><br><span class="line">                        R.string.unsuccessed, Toast.LENGTH_SHORT).show();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                Toast.makeText(MainActivity.this,</span><br><span class="line">                        R.string.successed, Toast.LENGTH_SHORT).show();</span><br><span class="line">                btn_register.setEnabled(<span class="literal">false</span>);</span><br><span class="line">                setTitle(R.string.registered);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private boolean checkSN(String userName, String sn) &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        <span class="keyword">if</span> ((userName == null) || (userName.length() == 0))</span><br><span class="line">            <span class="built_in">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> ((sn == null) || (sn.length() != 16))</span><br><span class="line">            <span class="built_in">return</span> <span class="literal">false</span>;</span><br><span class="line">        MessageDigest digest = MessageDigest.getInstance(<span class="string">&quot;MD5&quot;</span>);</span><br><span class="line">        digest.reset();</span><br><span class="line">        digest.update(userName.getBytes());</span><br><span class="line">        byte[] bytes = digest.digest();</span><br><span class="line">        String hexstr = toHexString(bytes, <span class="string">&quot;&quot;</span>);</span><br><span class="line">        StringBuilder sb = new StringBuilder();</span><br><span class="line">        <span class="keyword">for</span> (int i = 0; i &lt; hexstr.length(); i += 2) &#123;</span><br><span class="line">            sb.append(hexstr.charAt(i));</span><br><span class="line">        &#125;</span><br><span class="line">        String userSN = sb.toString();</span><br><span class="line">        Log.d(<span class="string">&quot;checkSN&quot;</span>, hexstr);</span><br><span class="line">        Log.d(<span class="string">&quot;checkSN&quot;</span>, userSN);</span><br><span class="line">        <span class="keyword">if</span> (!userSN.equalsIgnoreCase(sn))</span><br><span class="line">            <span class="built_in">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125; catch (NoSuchAlgorithmException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">        <span class="built_in">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private static String toHexString(byte[] bytes, String separator) &#123;</span><br><span class="line">    StringBuilder hexString = new StringBuilder();</span><br><span class="line">    <span class="keyword">for</span> (byte b : bytes) &#123;</span><br><span class="line">        String hex = Integer.toHexString(0xFF &amp; b);</span><br><span class="line">        <span class="keyword">if</span>(hex.length() == 1)&#123;</span><br><span class="line">            hexString.append(<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        hexString.append(hex).append(separator);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">return</span> hexString.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>运行界面：</p>
<div style="width:50%;margin:auto"><img data-src="/2022/10/16/analysis-of-android-program-decompile-and-resignature/Screenshot_2022-10-23-16-22-32-266_com.droider.crackme0201.jpg" class=""></div>

<p>点击按钮后让应用变为显示已注册的title</p>
<h3 id="破解思路顺序"><a href="#破解思路顺序" class="headerlink" title="破解思路顺序"></a>破解思路顺序</h3><ul>
<li>使用ApkTool反编译Apk,生成smail格式的反汇编代码</li>
<li>阅读smail代码理解程序运行机制，找到突破口，修改代码</li>
<li>使用ApkTool重新编译生成APK文件并对其签名</li>
<li>运行测试，反复以上步骤已达到破解</li>
</ul>
<h3 id="反编译Apk"><a href="#反编译Apk" class="headerlink" title="反编译Apk"></a>反编译Apk</h3><h4 id="安装ApkTool"><a href="#安装ApkTool" class="headerlink" title="安装ApkTool"></a>安装ApkTool</h4><p><a href="https://bitbucket.org/iBotPeaches/apktool/downloads/">ApkTool</a>: 提供了Android Apk的反编译与回编译功能，让Apk重新打包成为可能。</p>
<p>下载对应系统的Apktool jar并下载对应系统的<a href="https://ibotpeaches.github.io/Apktool/install/">运行时包装脚本</a><br>把这两个文件放到同一目录，然后添加到环境变量中</p>
<p>打开cmd输入：</p>
<div class="highlight-wrap" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">apktool -version</span><br></pre></td></tr></table></figure></div>
<br>
看到对应的版本，表示已经安装添加环境变量成功
<img data-src="/2022/10/16/analysis-of-android-program-decompile-and-resignature/Snipaste_2022-10-10_15-43-23.png" class="">

<h4 id="使用Apktool反编译Apk"><a href="#使用Apktool反编译Apk" class="headerlink" title="使用Apktool反编译Apk"></a>使用Apktool反编译Apk</h4><p>生成一个<a href="app-debug.apk">debug</a>版本的apk当前apk的目录下使用cmd窗口执行</p>
<div class="highlight-wrap" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">apktool d ./app-debug.apk -o outdir</span><br></pre></td></tr></table></figure></div>
<br>
会生成outdir文件夹，里面包含apk的反编译文件，接下来要分析里面的文件
<img data-src="/2022/10/16/analysis-of-android-program-decompile-and-resignature/Snipaste_2022-10-10_16-36-53.png" class="">

<h3 id="分析apk文件"><a href="#分析apk文件" class="headerlink" title="分析apk文件"></a>分析apk文件</h3><p>点击注册按钮会提示:无效用户名和注册码 这个地方和判断注册的关键逻辑有关，我们可以使用这个作为突破口。</p>
<h4 id="内部反编译文件顺序检索"><a href="#内部反编译文件顺序检索" class="headerlink" title="内部反编译文件顺序检索"></a>内部反编译文件顺序检索</h4><ul>
<li><p>这个字符可以硬编码在代码里，也可以写在res\values\string.xml里面。打包的时候string.xml的字符串被加密存储在resource.arsc文件并保存到apk包中，如果apk被反编译，这个文件也就解密了。从解密文件夹的res\values\string.xml找到改文案提示的name为unsuccessed</p>
</li>
<li><p>Android程序中，string.xml中的字符串资源都在gen&#x2F;R.java的String类中标识，每个字符串都有唯一的int类型索引值。<a href="https://blog.csdn.net/baidu_31093133/article/details/113700629">android studio找不到R.java文件怎么办？</a></p>
</li>
<li><p>使用Apktool反编译apk后这些int值保存在和string.xml同级的public.xml中。outdir&#x2F;res&#x2F;values&#x2F;public.xml中通过name为unsuccessed找到id为0x7f0d0028</p>
</li>
</ul>
<h4 id="全局搜索顺序检索"><a href="#全局搜索顺序检索" class="headerlink" title="全局搜索顺序检索"></a>全局搜索顺序检索</h4><p>如果是Mac和Linux可以使用命令 grep来查找</p>
<div class="highlight-wrap" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">grep -r <span class="string">&quot;无效用户名或注册码&quot;</span> outdir/</span><br><span class="line">// 找到name为unsuccessed</span><br><span class="line">grep -r unsuccessed outdir/</span><br><span class="line">// 找到<span class="built_in">id</span>为0x7f0d0028 并且还在outdir/smali/com/crackme0201/MainActivity<span class="variable">$1</span>.smail中使用过</span><br><span class="line"></span><br><span class="line"><span class="comment"># virtual methods</span></span><br><span class="line">.method public onClick(Landroid/view/View;)V</span><br><span class="line">.....</span><br><span class="line">.line 58</span><br><span class="line">    iget-object v0, p0, Lcom/droider/crackme0201/MainActivity<span class="variable">$1</span>;-&gt;this<span class="variable">$0</span>:Lcom/droider/crackme0201/MainActivity;</span><br><span class="line"></span><br><span class="line">    const v2, 0x7f0d0028</span><br><span class="line"></span><br><span class="line">    invoke-static &#123;v0, v2, v1&#125;, Landroid/widget/Toast;-&gt;makeText(Landroid/content/Context;II)Landroid/widget/Toast;</span><br><span class="line"></span><br><span class="line">    move-result-object v0</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>
<br>
这个代码在onClick方法里面调用，接下来需要阅读这个smali方法里面的代码，需要对照写的java代码来参考看

<h4 id="分析smali指令代码"><a href="#分析smali指令代码" class="headerlink" title="分析smali指令代码"></a>分析smali指令代码</h4><div class="highlight-wrap" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># virtual methods</span></span><br><span class="line">.method public onClick(Landroid/view/View;)V</span><br><span class="line">    .locals 3</span><br><span class="line">    .param p1, <span class="string">&quot;v&quot;</span>    <span class="comment"># Landroid/view/View;</span></span><br><span class="line"></span><br><span class="line">    .line 56</span><br><span class="line">	<span class="comment"># iget-object获取MainActivity实例的引用。-&gt;this$0是内部类MainActivity$1中的一个synthetic字段,存储的是父类MainActivity的引用。</span></span><br><span class="line">    iget-object v0, p0, Lcom/droider/crackme0201/MainActivity<span class="variable">$1</span>;-&gt;this<span class="variable">$0</span>:Lcom/droider/crackme0201/MainActivity;</span><br><span class="line">	<span class="comment"># 获取edit_userName这个EditText的引用（待确认）</span></span><br><span class="line">    invoke-static &#123;v0&#125;, Lcom/droider/crackme0201/MainActivity;-&gt;access<span class="variable">$000</span>(Lcom/droider/crackme0201/MainActivity;)Landroid/widget/EditText;</span><br><span class="line">	<span class="comment"># 把edit_userName的引用放到v1寄存器里面存储</span></span><br><span class="line">    move-result-object v1</span><br><span class="line">	<span class="comment"># edit_userName执行getText()方法获得Editable对应引用</span></span><br><span class="line">    invoke-virtual &#123;v1&#125;, Landroid/widget/EditText;-&gt;getText()Landroid/text/Editable;</span><br><span class="line">	<span class="comment"># 把v1寄存器里面赋值Editable对应引用</span></span><br><span class="line">    move-result-object v1</span><br><span class="line">	<span class="comment"># Editable对应引用执行toString方法</span></span><br><span class="line">    invoke-virtual &#123;v1&#125;, Ljava/lang/Object;-&gt;toString()Ljava/lang/String;</span><br><span class="line">	<span class="comment"># v1寄存器赋值存储edit_userName的String值</span></span><br><span class="line">    move-result-object v1</span><br><span class="line">	<span class="comment"># String值调用trim方法</span></span><br><span class="line">    invoke-virtual &#123;v1&#125;, Ljava/lang/String;-&gt;trim()Ljava/lang/String;</span><br><span class="line">	<span class="comment"># v1寄存器存储trim后的string值</span></span><br><span class="line">    move-result-object v1</span><br><span class="line"></span><br><span class="line">    iget-object v2, p0, Lcom/droider/crackme0201/MainActivity<span class="variable">$1</span>;-&gt;this<span class="variable">$0</span>:Lcom/droider/crackme0201/MainActivity;</span><br><span class="line"></span><br><span class="line">    .line 57</span><br><span class="line">	<span class="comment"># 获取edit_sn这个EditText的引用（待确认）</span></span><br><span class="line">    invoke-static &#123;v2&#125;, Lcom/droider/crackme0201/MainActivity;-&gt;access<span class="variable">$100</span>(Lcom/droider/crackme0201/MainActivity;)Landroid/widget/EditText;</span><br><span class="line">	<span class="comment"># 把edit_sn的引用放到v2寄存器里面存储</span></span><br><span class="line">    move-result-object v2</span><br><span class="line">	<span class="comment"># edit_sn执行getText()方法获得Editable对应引用</span></span><br><span class="line">    invoke-virtual &#123;v2&#125;, Landroid/widget/EditText;-&gt;getText()Landroid/text/Editable;</span><br><span class="line">	<span class="comment"># 把v2寄存器里面赋值Editable对应引用</span></span><br><span class="line">    move-result-object v2</span><br><span class="line">	<span class="comment"># Editable对应引用执行toString方法</span></span><br><span class="line">    invoke-virtual &#123;v2&#125;, Ljava/lang/Object;-&gt;toString()Ljava/lang/String;</span><br><span class="line">	<span class="comment"># v2寄存器赋值存储edit_sn的String值</span></span><br><span class="line">    move-result-object v2</span><br><span class="line">	<span class="comment"># String值调用trim方法</span></span><br><span class="line">    invoke-virtual &#123;v2&#125;, Ljava/lang/String;-&gt;trim()Ljava/lang/String;</span><br><span class="line">	<span class="comment"># v2寄存器存储trim后的string值</span></span><br><span class="line">    move-result-object v2</span><br><span class="line"></span><br><span class="line">    .line 56</span><br><span class="line">	<span class="comment"># 执行checkSN方法</span></span><br><span class="line">    invoke-static &#123;v0, v1, v2&#125;, Lcom/droider/crackme0201/MainActivity;-&gt;access<span class="variable">$200</span>(Lcom/droider/crackme0201/MainActivity;Ljava/lang/String;Ljava/lang/String;)Z</span><br><span class="line">	<span class="comment"># vo寄存器存储checkSN方法的值</span></span><br><span class="line">    move-result v0</span><br><span class="line">	</span><br><span class="line">    const/4 v1, 0x0</span><br><span class="line">	<span class="comment"># 对v0寄存器进行判断为真(不为0/为true)就跳转到cond_0</span></span><br><span class="line">    if-nez v0, :cond_0</span><br><span class="line"></span><br><span class="line">    .line 58</span><br><span class="line">	<span class="comment"># if-nez v0判断为false，因为checkSN取反</span></span><br><span class="line">    iget-object v0, p0, Lcom/droider/crackme0201/MainActivity<span class="variable">$1</span>;-&gt;this<span class="variable">$0</span>:Lcom/droider/crackme0201/MainActivity;</span><br><span class="line">	<span class="comment"># 把unsuccessed的值赋给v2寄存器</span></span><br><span class="line">    const v2, 0x7f0d0028</span><br><span class="line">	<span class="comment"># 执行Toast的makeText方法</span></span><br><span class="line">    invoke-static &#123;v0, v2, v1&#125;, Landroid/widget/Toast;-&gt;makeText(Landroid/content/Context;II)Landroid/widget/Toast;</span><br><span class="line">	<span class="comment"># 获得Toast对象引用赋值给v0</span></span><br><span class="line">    move-result-object v0</span><br><span class="line"></span><br><span class="line">    .line 59</span><br><span class="line">	<span class="comment"># 执行Toast的show方法</span></span><br><span class="line">    invoke-virtual &#123;v0&#125;, Landroid/widget/Toast;-&gt;show()V</span><br><span class="line"></span><br><span class="line">    goto :goto_0</span><br><span class="line"></span><br><span class="line">    .line 61</span><br><span class="line">    :cond_0</span><br><span class="line">	<span class="comment"># 以下为!checkSN()整体为false后要走的注册成功代码逻辑，下面每条执行分析参考上面的分析</span></span><br><span class="line">    iget-object v0, p0, Lcom/droider/crackme0201/MainActivity<span class="variable">$1</span>;-&gt;this<span class="variable">$0</span>:Lcom/droider/crackme0201/MainActivity;</span><br><span class="line"></span><br><span class="line">    const v2, 0x7f0d0025</span><br><span class="line"></span><br><span class="line">    invoke-static &#123;v0, v2, v1&#125;, Landroid/widget/Toast;-&gt;makeText(Landroid/content/Context;II)Landroid/widget/Toast;</span><br><span class="line"></span><br><span class="line">    move-result-object v0</span><br><span class="line"></span><br><span class="line">    .line 62</span><br><span class="line">    invoke-virtual &#123;v0&#125;, Landroid/widget/Toast;-&gt;show()V</span><br><span class="line"></span><br><span class="line">    .line 63</span><br><span class="line">    iget-object v0, p0, Lcom/droider/crackme0201/MainActivity<span class="variable">$1</span>;-&gt;this<span class="variable">$0</span>:Lcom/droider/crackme0201/MainActivity;</span><br><span class="line"></span><br><span class="line">    invoke-static &#123;v0&#125;, Lcom/droider/crackme0201/MainActivity;-&gt;access<span class="variable">$300</span>(Lcom/droider/crackme0201/MainActivity;)Landroid/widget/Button;</span><br><span class="line"></span><br><span class="line">    move-result-object v0</span><br><span class="line"></span><br><span class="line">    invoke-virtual &#123;v0, v1&#125;, Landroid/widget/Button;-&gt;setEnabled(Z)V</span><br><span class="line"></span><br><span class="line">    .line 64</span><br><span class="line">    iget-object v0, p0, Lcom/droider/crackme0201/MainActivity<span class="variable">$1</span>;-&gt;this<span class="variable">$0</span>:Lcom/droider/crackme0201/MainActivity;</span><br><span class="line"></span><br><span class="line">    const v1, 0x7f0d0021</span><br><span class="line"></span><br><span class="line">    invoke-virtual &#123;v0, v1&#125;, Lcom/droider/crackme0201/MainActivity;-&gt;setTitle(I)V</span><br><span class="line"></span><br><span class="line">    .line 66</span><br><span class="line">    :goto_0</span><br><span class="line">    return-void</span><br><span class="line">.end method</span><br></pre></td></tr></table></figure></div>

<p>如上面的分析，弹出注册成功提示标识注册成功,所以主要修改line 57里面的<font color=red>if-nez v0, :cond_0</font>这条指令就好。</p>
<ul>
<li>if-nez：Dalvik指令集中的一个条件跳转指令</li>
<li>if-eqz: 与ifnez相反，表示比较结果为0（为false）时就跳转</li>
</ul>
<p><strong>分析结论</strong>：把line 57里面的<font color=red>if-nez v0, :cond_0</font>修改为<font color=red>if-eqz v0, :cond_0</font>就好，修改后要重新进行打包。</p>
<h4 id="重新编译Apk文件并签名"><a href="#重新编译Apk文件并签名" class="headerlink" title="重新编译Apk文件并签名"></a>重新编译Apk文件并签名</h4><h5 id="重新回编apk"><a href="#重新回编apk" class="headerlink" title="重新回编apk"></a>重新回编apk</h5><p>回编命令：</p>
<div class="highlight-wrap" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">apktool b outdir</span><br></pre></td></tr></table></figure></div>
<br>

<p>如果成功在&#x2F;outdir&#x2F;dist&#x2F;app-debug.apk重新生成的apk在这个位置，注意这个apk是没有签名的，需要签名后安装</p>
<h5 id="签名回编的apk"><a href="#签名回编的apk" class="headerlink" title="签名回编的apk"></a>签名回编的apk</h5><h6 id="使用v1签名重新签名apk"><a href="#使用v1签名重新签名apk" class="headerlink" title="使用v1签名重新签名apk"></a>使用v1签名重新签名apk</h6><p>  所需文件：<br>  signapk.jar，testkey.x509.pem,testkey.pk8，网上搜可以从android系统源码中获取，我从网上找了份，可以<a href="signapk.jar.zip">点击链接</a>直接下载这三个文件</p>
<p>  执行签名命令：<br>      <div class="highlight-wrap" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">java -jar signapk.jar testkey.x509.pem testkey.pk8 app-debug.apk app-debug-sign.apk</span><br></pre></td></tr></table></figure></div></p>
<p>  安装签名好的apk试试：<br>    <div class="highlight-wrap" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">adb install app-debug-sign.apk</span><br></pre></td></tr></table></figure></div></p>
<p>  得到执行v1签名的apk: app-debug-sign.apk , 安装后出现如下错误：<br>  <code>Performing Streamed Install adb: failed to install app-debug-sign.apk: Failure [-124: Failed parse during installPackageLI: Targeting R+ (version 30 and above) requires the resources.arsc of installed APKs to be stored uncompressed and aligned on a 4-byte boundary]</code></p>
<p>这里需要做字节对齐，详细知识点点击此处了解<a href="https://developer.android.com/studio/command-line/zipalign">zipalign</a>，<a href="https://forum.xda-developers.com/t/tool-windows-batch-apk-zipalign-tool-v-2-0-23-05-2022.3791644/">分享一个下载链接</a><br>同样可以在博文这里下载<a href="Zipalign_Tool_v2.0.zip">zipalign</a>工具压缩包：<br>    执行字节对齐命令：<br>    <div class="highlight-wrap" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">zipalign -p -f -v 4 app-debug-sign.apk app-debug-sign-zipalign.apk</span><br></pre></td></tr></table></figure></div></p>
<p>确认对齐方式：<br>    <div class="highlight-wrap" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">zipalign -c -v 4 app-debug-sign-zipalign.apk</span><br></pre></td></tr></table></figure></div></p>
<p>或者执行写好的批量处理脚本&#x2F;Zipalign_Tool_v2.0&#x2F;zipalign.bat得到对齐后的apk再安装试试：<br>    <div class="highlight-wrap" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">adb install app-debug-sign-zipalign.apk</span><br></pre></td></tr></table></figure></div></p>
<p>安装<a href="app-debug-sign-zipalign.apk">app-debug-sign-zipalign.apk</a>又得到如下错误。。。难受：<br>    <code>Performing Streamed Install adb: failed to install app-debug-sign.apk: Failure [INSTALL_PARSE_FAILED_NO_CERTIFICATES: Scanning Failed.: No signature found in package of version 2 or newer for package com.droider.crackme0201]</code></p>
<p>   因为是说<font color=red>Android R上不支持使用v1签名</font>了，要用v2或更高签名，那我这边找一台版本低于Android R的机器试试看，本地使用一台Android Q 的vivo X21A验证可以安装成功，直接点击注册可以单独上方提示成功了<br>   <div style="width:50%;margin:auto"><img data-src="/2022/10/16/analysis-of-android-program-decompile-and-resignature/Screenshot_20221019_224316.jpg" class=""></div></p>
<h6 id="使用v2签名重新签名apk"><a href="#使用v2签名重新签名apk" class="headerlink" title="使用v2签名重新签名apk"></a>使用v2签名重新签名apk</h6><ul>
<li>v2签名介绍<br>   上面使用v1签名没法在Android R以上的设备上运行，一种方法是开发应用的targetSdkVersion降级，这对于多数场景显然不可取，另外一种是使用Android R以上支持的v2签名，v2要使用ApkSigner工具进行签名</li>
</ul>
<p>   ApkSigner:内置在 Android SDK Build Tools 24.0.3 及更高的版本中,示例位置： sdk\build-tools\29.0.0\lib\apksigner.jar,本地提供一个<a href="apksigner.jar">apksigner.jar</a>的包</p>
<p>   <a href="https://source.android.com/docs/security/features/apksigning/v2">官方文档介绍v2</a></p>
<blockquote>
<p> APK 签名方案 v2 是在 Android 7.0 (Nougat) 中引入的。为了使 APK 可在 Android 6.0 (Marshmallow) 及更低版本的设备上安装，应先使用 JAR 签名功能对 APK 进行签名，然后再使用 v2 方案对其进行签名。</p>
</blockquote>
<p>   <a href="https://developer.android.com/studio/command-line/zipalign">zipalign注意事项:</a></p>
<blockquote>
<p>注意：您必须在应用构建过程中的两个特定时间点之一使用 zipalign，具体在哪个时间点使用，取决于您所使用的应用签名工具：如果您使用的是 apksigner，只能在为 APK 文件签名之前执行 zipalign。如果您在使用 apksigner 为 APK 签名之后对 APK 做出了进一步更改，签名便会失效。<br>如果您使用的是 jarsigner，只能在为 APK 文件签名之后执行 zipalign。</p>
</blockquote>
<p>   **小结：v2签名顺序为v1签名-&gt;zipalign-&gt;v2签名</p>
<ul>
<li><p>使用v2签名<br>v2签名需要有一个自己的签名证书，我们使用keytool生成一个签名文件需要使用keytool自己生成一个,keytool在jdk目录：jdk1.8.0_31\jre\bin 下</p>
<ul>
<li>生成签名文件<a href="test.keystore">test.keystore</a></li>
</ul>
<p> 执行如下命令：<br>   <div class="highlight-wrap" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">keytool -genkey -<span class="built_in">alias</span> testalias -keyalg RSA -keysize 2048 -validity 36500 		-keystore test.keystore</span><br></pre></td></tr></table></figure></div></p>
<p> 然后输入如下信息：<br> <div style="width:50%;margin:auto"><img data-src="/2022/10/16/analysis-of-android-program-decompile-and-resignature/Screenshot_20221019_224316.jpg" class=""></div><br> 密码输入为：123456<br> 可以如下指令查看证书详情：<br> <div class="highlight-wrap" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">keytool -list -v -keystore test.keystore  </span><br><span class="line">Enter keystore password: //输入密码，回车</span><br></pre></td></tr></table></figure></div></p>
<ul>
<li>执行v2签名指令</li>
</ul>
<p> 使用我们上面用v1做好zipalign对齐的apk执行如下命令：<br> <div class="highlight-wrap" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">java -jar apksigner.jar sign --ks &#123;签名文件路径&#125; --ks-key-alias &#123;Key_alias&#125; --ks-pass pass:&#123;KeyStore_Password&#125; --key-pass pass:&#123;Key_Password&#125; --out &#123;V2签名后的APK文件&#125; &#123;对齐后的APK文件&#125;</span><br></pre></td></tr></table></figure></div></p>
<p> 对应本地文件路径指令：<br> <div class="highlight-wrap" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">java -jar apksigner.jar sign --ks test.keystore --ks-key-alias testalias --ks-pass pass:123456 --key-pass pass:123456 --out app-debug-sign_v2.apk app-debug-sign-zipalign.apk</span><br></pre></td></tr></table></figure></div></p>
<p> 得到<a href="app-debug-sign_v2.apk">app-debug-sign_v2.apk</a>在Android R或以上设备运行成功</p>
<p> 查看apk文件签名情况可以使用如下命令：<br> <div class="highlight-wrap" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">java -jar apksigner.jar verify -v app-debug-sign_v2.apk</span><br><span class="line">Verifies</span><br><span class="line">Verified using v1 scheme (JAR signing): <span class="literal">true</span></span><br><span class="line">Verified using v2 scheme (APK Signature Scheme v2): <span class="literal">true</span></span><br><span class="line">Verified using v3 scheme (APK Signature Scheme v3): <span class="literal">true</span></span><br></pre></td></tr></table></figure></div></p>
<ul>
<li>进阶跳过v1签名步骤<br> 可以看到v2签名是兼容了v1的，但是这个操作好像比较繁琐，可以使用<a href="https://developer.android.com/studio/command-line/apksigner?hl=zh">apksigner.jar</a>文档里面的命令–v1-signing-enabled跳过v1签名的步骤，它可以兼容v1签名，一般会根据sdk版本它已经帮我们做好了v1兼容, 使用[app-debug-reverse.apk] (app-debug-reverse.apk  )做了zipalign对其的<a href="app-debug-reverse-zipalign.apk">app-debug-reverse-zipalign.apk</a> 直接v2签名后得到<a href="app-debug-reverse-zipalign-sign_v2.apk">app-debug-reverse-zipalign-sign_v2.apk</a></li>
</ul>
  <div class="highlight-wrap" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"> // 字节对齐</span><br><span class="line"> zipalign -p -f -v 4 app-debug-reverse.apk app-debug-reverse-zipalign.apk</span><br><span class="line"> // 签名</span><br><span class="line">java -jar apksigner.jar sign --ks test.keystore --ks-key-alias testalias --ks-pass pass:123456 --key-pass pass:123456 --v1-signing-enabled <span class="literal">true</span> --out app-debug-reverse-zipalign-sign_v2.apk app-debug-reverse-zipalign.apk</span><br></pre></td></tr></table></figure></div>
 <br>
 查看直接使用v2签名的apk支持签名情况：
 
 <div class="highlight-wrap" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">java -jar apksigner.jar verify -v app-debug-reverse-zipalign-sign_v2.apk</span><br><span class="line">Verifies</span><br><span class="line">Verified using v1 scheme (JAR signing): <span class="literal">true</span></span><br><span class="line">Verified using v2 scheme (APK Signature Scheme v2): <span class="literal">true</span></span><br><span class="line">Verified using v3 scheme (APK Signature Scheme v3): <span class="literal">true</span></span><br><span class="line">Number of signers: 1</span><br></pre></td></tr></table></figure></div>
 <br>
 可以看到这个apk没有手动进行v1签名，但是它是支持v1的，完结!</li>
</ul>
]]></content>
      <categories>
        <category>Android</category>
        <category>逆向</category>
        <category>《Android软件安全权威指南》实践笔记</category>
      </categories>
      <tags>
        <tag>Android逆向</tag>
      </tags>
  </entry>
  <entry>
    <title>服务器搭建Git服务端</title>
    <url>/2022/10/13/setup-git-server/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>此文符合自己购买了Vps服务器，並且需要自己存放相应的一些私有代碼，不想放置到公共服务器上，自己存放使用代碼用。如果是公司要多人协同使用，那需要其他的方式了。</p>
<h2 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h2><blockquote>
<p><strong>Vps服务器系統：</strong> Ubuntu 18.04 LTS x64</p>
<p><strong>Vps服务器Git版本：</strong> 2.17.1</p>
<p><strong>客戶端连接OS：</strong> Mac OS</p>
</blockquote>
<h2 id="服务器配置"><a href="#服务器配置" class="headerlink" title="服务器配置"></a>服务器配置</h2><ul>
<li><p>安装git:</p>
<div class="highlight-wrap" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt-get install git</span><br></pre></td></tr></table></figure></div>
</li>
<li><p>创建git用户组和用户，用于运行git服务<br><strong>添加git用戶的時候记住添加git用户的密码，后续客户端clone代码的时候需要使用</strong></p>
<div class="highlight-wrap" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">groupadd git</span><br><span class="line">useradd git -g git</span><br></pre></td></tr></table></figure></div></li>
<li><p>配置证书登陆信息<br>收集所有需要登录的用户的公钥，公钥位于客户端电脑的id_rsa.pub文件中（配置有多个公钥的话，取这个的配置就好），把我们的公钥导入到&#x2F;home&#x2F;git&#x2F;.ssh&#x2F;authorized_keys文件里，一行一个。</p>
<div class="highlight-wrap" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> /home/git/</span><br><span class="line"><span class="built_in">mkdir</span> .ssh</span><br><span class="line"><span class="built_in">chmod</span> 755 .ssh</span><br><span class="line"><span class="built_in">touch</span> .ssh/authorized_keys</span><br><span class="line"><span class="built_in">chmod</span> 644 .ssh/authorized_keys</span><br></pre></td></tr></table></figure></div></li>
<li><p>初始化Git仓库<br>git仓库的代码位置自己设置一个目录位置，也可以安装如下位置创建</p>
<div class="highlight-wrap" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> /home</span><br><span class="line"><span class="built_in">mkdir</span> gitrepo</span><br><span class="line"><span class="built_in">chown</span> git:git gitrepo/</span><br><span class="line"><span class="built_in">cd</span> gitrepo</span><br><span class="line">git init --bare hexo.git</span><br><span class="line">Initialized empty Git repository <span class="keyword">in</span> /home/gitrepo/hexo.git/</span><br></pre></td></tr></table></figure></div>
<p>Git就会创建一个裸仓库，裸仓库<strong>没有工作区</strong>，因为服务器上的Git仓库纯粹是为了共享，所以不让用户直接登录到服务器上去改工作区，并且服务器上的Git仓库通常都以.git结尾。然后，把owner改为git</p>
<div class="highlight-wrap" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">hown -R git:git hexo.git</span><br></pre></td></tr></table></figure></div></li>
<li><p>安全禁用shell登陆<br>出于安全考虑，创建的git用户不允许登录shell，这可以通过编辑&#x2F;etc&#x2F;passwd文件完成。找到类似下面的一行</p>
<div class="highlight-wrap" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">git:x:1001:1001:,,,:/home/git:/bin/bash</span><br></pre></td></tr></table></figure></div>
<p>修改为：</p>
<div class="highlight-wrap" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">git:x:1001:1001:,,,:/home/git:/usr/bin/git-shell</span><br></pre></td></tr></table></figure></div></li>
</ul>
<h2 id="客户端拉取代码"><a href="#客户端拉取代码" class="headerlink" title="客户端拉取代码"></a>客户端拉取代码</h2><h3 id="clone-服务器git項目"><a href="#clone-服务器git項目" class="headerlink" title="clone 服务器git項目"></a>clone 服务器git項目</h3><p>客户端确认安装了git执行如下指令，其中server换为自己的Vps服务器的IP地址，密码为上面设置git用户的时候设置的密码：</p>
<div class="highlight-wrap" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> git@server:/home/gitrepo/hexo.git</span><br><span class="line">Cloning into <span class="string">&#x27;hexo&#x27;</span>...</span><br><span class="line">git@server<span class="string">&#x27;s password: </span></span><br></pre></td></tr></table></figure></div>
<p>如果ssh服务器的端口不是22的话，还需要补上端口整体格式为</p>
<div class="highlight-wrap" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> ssh://git@server:port/home/gitrepo/hexo.git</span><br><span class="line">Cloning into <span class="string">&#x27;hexo&#x27;</span>...</span><br><span class="line">git@server<span class="string">&#x27;s password: </span></span><br></pre></td></tr></table></figure></div>

<h3 id="push本地修改到到服务器问题记录"><a href="#push本地修改到到服务器问题记录" class="headerlink" title="push本地修改到到服务器问题记录"></a>push本地修改到到服务器问题记录</h3><div class="highlight-wrap" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">fatal: &#x27;home/gitrepo/hexo.git&#x27; does not appear to be a git repository</span><br><span class="line">fatal: Could not read from remote repository.</span><br><span class="line">Please make sure you have the correct access rights</span><br><span class="line">and the repository exists.</span><br></pre></td></tr></table></figure></div>
<p>这个提示权限不对，大概率是本地电脑的id_rsa.pub公钥没有填到服务器的&#x2F;home&#x2F;git&#x2F;.ssh&#x2F;authorized_keys，填上再试试，我本地有多个公钥验证填写默认使用的git配置id_rsa.pub里面的就好</p>
<p>有其他配置问题，欢迎留言交流</p>
]]></content>
      <categories>
        <category>工具箱</category>
        <category>开发工具</category>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>Dalvik 格式与字节码规范</title>
    <url>/2022/10/18/dalvik-format-and-bytecode/</url>
    <content><![CDATA[<p>Android 4.4之后Google使用ART（Android Runtime）虚拟机，将由JIT执行的Dalvik切换为AOT编译的ART。ART可以完整的对Dalvik可执行格式以及字节码规范支持，本节我们先了解Dalvik虚拟机的特性以及Dalvik字节码的汇编语言，为后面了解ART虚拟机打基础。</p>
<h2 id="Dalvik虚拟机"><a href="#Dalvik虚拟机" class="headerlink" title="Dalvik虚拟机"></a>Dalvik虚拟机</h2><p>Dalvik虚拟机于2007年年底正式发布了了Android SDK，Dalvik虚拟机开始进入人们的视野。</p>
<h3 id="Dalvik虚拟机的特点"><a href="#Dalvik虚拟机的特点" class="headerlink" title="Dalvik虚拟机的特点"></a>Dalvik虚拟机的特点</h3><ul>
<li>体积小，占用内存空间少</li>
<li>专有的DEX可执行文件格式，体积小，执行速度快</li>
<li>常量池采用32位索引值，对方法名，字段名，常量的寻址速度快</li>
<li>基于寄存器架构，同时拥有一套完整的指令系统</li>
<li>提供了对象生命周期管理，堆栈管理，线程管理，安全和异常以及垃圾回收等功能</li>
<li>所有的Android程序都运行在Android系统进程中，每个进程都与一个Dalvik虚拟机实例对应</li>
</ul>
<h3 id="Dalvik虚拟机与Java虚拟机的区别"><a href="#Dalvik虚拟机与Java虚拟机的区别" class="headerlink" title="Dalvik虚拟机与Java虚拟机的区别"></a>Dalvik虚拟机与Java虚拟机的区别</h3><p>Dalvik虚拟机与Java虚拟机互不兼容，有如下主要区别</p>
<h4 id="运行的字节码不同："><a href="#运行的字节码不同：" class="headerlink" title="运行的字节码不同："></a>运行的字节码不同：</h4><p>Java虚拟机运行Java字节码，Dalvik虚拟机运行Dalvik字节码。</p>
<table>
<thead>
<tr>
<th align="center">Java虚拟机</th>
<th align="center">Dalvik虚拟机</th>
</tr>
</thead>
<tbody><tr>
<td align="center">运行Java字节码</td>
<td align="center">运行Dalvik字节码</td>
</tr>
<tr>
<td align="center">解码class文件执行</td>
<td align="center">解码Dex（class转换来）文件执行</td>
</tr>
</tbody></table>
<h4 id="Dalvik可执行文件体积更小"><a href="#Dalvik可执行文件体积更小" class="headerlink" title="Dalvik可执行文件体积更小"></a>Dalvik可执行文件体积更小</h4><p>将Java字节码转换为Dalvik字节码是由dx(androidsdk&#x2F;build-tools&#x2F;30.0.1&#x2F;dx)工具完成。dx能重新排列Java类文件，消除在类文件中出现的所有冗余信息，虚拟机在初始化时反复加载和解析文件。<br>Java类文件中通常有多个方法签名，如果其他类文件引用了该类文件的方法，相应的方法签名也会被复制到其他类文件中。也就是说如果多个不同的类同时保护相同的签名方法，大量的字符串常量会被多个类文件重复使用。这些冗余信息造成文件体积增大会严重影响虚拟机解析文件的效率。</p>
<p>dx对所有Java类文件中的常量池进行分解，消除其中的冗余信息，然后将它们重新组合成一个常量池，并让所有类文件共享这个常量池。</p>
<p>使用dx将Java文件转换为DEX的过程，如下图所示，基于dx对常量池的压缩，相同的字符串和常量在DEX文件中只会出现一次</p>
<div style="width:50%;margin:auto"><img data-src="/2022/10/18/dalvik-format-and-bytecode/1666057320770.jpg" class=""></div>

<h4 id="虚拟机架构不同"><a href="#虚拟机架构不同" class="headerlink" title="虚拟机架构不同"></a>虚拟机架构不同</h4><ul>
<li>Java虚拟机基于栈架构：当程序运行时，Java虚拟机会频繁的对栈进行读写数据的操作。这个过程中，不仅会多次进行指令的分派和内存访问，而且会消耗大量的CPU时间。对手机不友好</li>
<li>Dalvik虚拟机基于寄存器架构：数据的访问直接在寄存器之间传递，比栈的方式要快很多</li>
</ul>
<h4 id="分析字节码文件"><a href="#分析字节码文件" class="headerlink" title="分析字节码文件"></a>分析字节码文件</h4><p>使用如下代码学习Java字节码和Dalvik字节码的区别，测试代码Hello.java如下：<br>    <div class="highlight-wrap" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">public class Hello &#123;</span><br><span class="line">public int foo(int a, int b) &#123;</span><br><span class="line">   		<span class="built_in">return</span> (a + b) * (a - b);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">		Hello hello = new Hello();</span><br><span class="line">		System.out.println(hello.foo(5, 3));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></p>
<h5 id="Java字节码分析"><a href="#Java字节码分析" class="headerlink" title="Java字节码分析"></a>Java字节码分析</h5><p>编译Java源文件，指定JDK 8对应（1.8）：</p>
<div class="highlight-wrap" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">javac -<span class="built_in">source</span> 1.8 -target 1.8 Hello.java </span><br></pre></td></tr></table></figure></div>
<br>

<p>使用javap反编译Hello.class，查看foo()函数的Java字节码：</p>
<div class="highlight-wrap" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">javap -c -classpath . Hello</span><br></pre></td></tr></table></figure></div>
<br>
得到Hello.class的Java字节码信息：
<div class="highlight-wrap" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">public int foo(int, int);</span><br><span class="line">Code:</span><br><span class="line">   0: iload_1</span><br><span class="line">   1: iload_2</span><br><span class="line">   2: iadd</span><br><span class="line">   3: iload_1</span><br><span class="line">   4: iload_2</span><br><span class="line">   5: isub</span><br><span class="line">   6: imul</span><br><span class="line">   7: ireturn</span><br></pre></td></tr></table></figure></div>
<br>
以上Java字节码占8字节，代码中的每条指令占用1字节且没有参数，它是如何存取数据的勒？
Java程序每个线程执行时都有一个PC计数器和一个Java栈。PC计数器以字节为单位记录当前运行位置和方法开头之间的偏移量，PC计数器只对当前方法有效，Java虚拟机通过它的值来取指令并执行。Java栈用于记录Java方法调用的活动记录，以帧（frame）为单位保存线程运行状态：每调用一个方法，就会分配一个新的栈帧并压入Java栈；每从一个方法返回，则弹出并撤销相应的栈帧。每个栈帧都包括局部变量区，求值栈（JVM规范中称其为操作数栈）及其他信息。局部变量区用于存储方法的参数和局部变量，参数安装源码中从左到右的顺序保存在局部变量区开头的几个slot中。
开始分析以上指令信息：

<ul>
<li><p>0: iload_1<br>这个指令分为iload和1两个部分，iload时JVM指令集load系列指令中的一条。i是指令前缀，表示操作类型为int；load表示局部变量存入Java栈；第二部分表示要操作的是哪个局部变量。索引值从0开始计数。iload_1表示使第二个int类型的局部变量入栈，而这个局部变量就是存放在局部变量区foo（）函数的第二个参数。</p>
<div style="width:50%;margin:auto"><img data-src="/2022/10/18/dalvik-format-and-bytecode/20221018-191004@2x.png" class=""></div>
</li>
<li><p>1: iload_2:用于取第三个参数</p>
</li>
<li><p>2: iadd：用于从栈顶弹出两个int类型的值并把它们求和，把结果压入栈顶</p>
</li>
<li><p>3: iload_1，4: iload_2：再次压入第2个和第3个参数。</p>
</li>
<li><p>5: isub：用于从栈顶弹出两个int类型的值并求差，把结果压入栈顶</p>
</li>
<li><p>7: ireturn：用于返回一个int类型的值</p>
</li>
</ul>
<p>详细了解Java虚拟机字节码的其他内容可以看这里：<a href="https://en.wikipedia.org/wiki/List_of_Java_bytecode_instructions">https://en.wikipedia.org/wiki/List_of_Java_bytecode_instructions</a></p>
<h5 id="Dex字节码分析"><a href="#Dex字节码分析" class="headerlink" title="Dex字节码分析"></a>Dex字节码分析</h5><p>把生成的<a href="Hello.class">Hello.class</a>文件用于生成<a href="Hello.dex">Hello.dex</a>DEX文件，使用dx工具：</p>
<div class="highlight-wrap" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">./dx --dex --output=Hello.dex Hello.class</span><br></pre></td></tr></table></figure></div>
<br>

<p>使用dexdump(位于androidsdk&#x2F;build-tools&#x2F;30.0.1&#x2F;)执行如下代码查看Dalvik字节码foo()方法</p>
<div class="highlight-wrap" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">./dexdump -d Hello.dex</span><br></pre></td></tr></table></figure></div>
<p>得到如下字节码文件：</p>
<div class="highlight-wrap" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"> Virtual methods   -</span><br><span class="line">    <span class="comment">#0              : (in LHello;)</span></span><br><span class="line">      name          : <span class="string">&#x27;foo&#x27;</span></span><br><span class="line">      <span class="built_in">type</span>          : <span class="string">&#x27;(II)I&#x27;</span></span><br><span class="line">      access        : 0x0001 (PUBLIC)</span><br><span class="line">      code          -</span><br><span class="line">      registers     : 5</span><br><span class="line">      ins           : 3</span><br><span class="line">      outs          : 0</span><br><span class="line">      insns size    : 6 16-bit code units</span><br><span class="line">000198:                                        |[000198] Hello.foo:(II)I</span><br><span class="line">0001a8: 9000 0304                              |0000: add-int v0, v3, v4</span><br><span class="line">0001ac: 9101 0304                              |0002: sub-int v1, v3, v4</span><br><span class="line">0001b0: b210                                   |0004: mul-int/2addr v0, v1</span><br><span class="line">0001b2: 0f00                                   |0005: <span class="built_in">return</span> v0</span><br><span class="line">      catches       : (none)</span><br><span class="line">      positions     : </span><br><span class="line">        0x0000 line=3</span><br><span class="line">      locals        : </span><br><span class="line">        0x0000 - 0x0006 reg=2 this LHello; </span><br><span class="line">        0x0000 - 0x0006 reg=3 (null) I </span><br><span class="line">        0x0000 - 0x0006 reg=4 (null) I</span><br></pre></td></tr></table></figure></div>
<br>
其他的描述信息不用看，Dalvik虚拟机只用了四条指令完成以上计算：

<ul>
<li>add-int v0, v3, v4：用于将v3和v4寄存器相加，将结果保存在v0寄存器中。v3&amp;v4表示函数的第一和第二个参数</li>
<li>sub-int v1, v3, v4：用于将v3&amp;v4寄存器相减，将结果保存在v1寄存器中</li>
<li>mul-int&#x2F;2addr v0, v1：将v0和v1寄存器相乘，将结果保存在v0寄存器中</li>
<li>return v0：返回v0寄存器的值</li>
</ul>
<p>Dalvik虚拟机运行时为每个线程也维护了一个PC计数器和一个调用栈。与Java虚拟机不同的是，这个调用栈维护了一个寄存器列表，寄存器的数量在方法结构体register字段中给出。Dalvik虚拟机会根据这个值来创建一份虚拟的寄存器列表。虚拟机运行状态如下图：</p>
<div style="width:50%;margin:auto"><img data-src="/2022/10/18/dalvik-format-and-bytecode/1666095337042.jpg" class=""></div>
可以看出Dalvik虚拟机生成的代码指令减少了，在程序上执行速度会快一点。

<h3 id="虚拟机的执行流程"><a href="#虚拟机的执行流程" class="headerlink" title="虚拟机的执行流程"></a>虚拟机的执行流程</h3><p>Android 系统启动并加载内核后，会立即执行init进程。init进程先完成设备的初始化工作，再读取init.rc文件并启动系统中重要的外部程序Zygote。</p>
<p>Zygote是Android系统中所有进程的孵化器进程。Zygote启动后会先执行Dalvik虚拟机，再启动system_server进程并进入Zygote模式，通过socket等侯命令的下达。在执行一个Android<br>应用程序时，system_server进程通过Binder IPC的方式将命令发送给Zygote。Zygote收到命令后，通过fork其自身创建一个Dalvik虚拟机的实例来执行应用程序的入口函数，完成程序的启动过程，如下图所示：</p>
<div style="width:80%;margin:auto"><img data-src="/2022/10/18/dalvik-format-and-bytecode/1666102809575.jpg" class=""></div>
Zygote提供三种创建进程方式：

<ul>
<li>fork： 创建一个Zygote进程（这种方式实际上不会被调用）</li>
<li>forkAndSpecialize：创建一个非Zygote进程</li>
<li>forkSystemServer：创建一个系统服务进程</li>
</ul>
<p>进程fork成功后，执行工作将交给Dalvik虚拟机来完成。</p>
<p>Dalvik虚拟机通过loadClassFromDex装载类。每个类成功解析后，有一个运行时的一个ClassObject类型的数据结构。接下来字节码验证器使用dvmVerifyCodeFlow函数对装入代码验证，虚拟机调用FindClass函数并装载main方法类。最后虚拟机调用dvmInterpret函数来初始化解释器并执行字节码流。</p>
<h3 id="虚拟机的执行方式"><a href="#虚拟机的执行方式" class="headerlink" title="虚拟机的执行方式"></a>虚拟机的执行方式</h3><p>即时编译（JIT）又称为动态编译，是一种通过运行时将字节码翻译为机器码使得程序的执行速度加快的技术。主流的JIT包括两种字节码编译方式：</p>
<ul>
<li>method方式：以函数为单位进行编译</li>
<li>trace方式：以trace为单位进行编译。只有少数代码是顺序执行的，多数代码都有好几条执行路径，而其中一些路径在实际运行过程中很少执行，这部分路径称为“冷路径”（执行比较频繁的路径为“热路径”）。method方式会编译整个方法的代码，从而在冷路径上耗费很多的编译时间和内存。使用trace方式进行编译，则能快速获取热路径的代码，缩短编译时间和内存。</li>
</ul>
<p>Dalvik虚拟机默认使用trace方式编译代码，同时支持method方式</p>
<h2 id="Dalvik语言基础"><a href="#Dalvik语言基础" class="headerlink" title="Dalvik语言基础"></a>Dalvik语言基础</h2><p>Dalvik虚拟机有专门的指令集及指令格式（Dalvik Executable Format）和调用规范。由Dalvik指令集组成的代码称为Dalvik汇编代码，由这种代码表示的语言称为Dalvik汇编语言。</p>
<h3 id="Dalvik指令格式"><a href="#Dalvik指令格式" class="headerlink" title="Dalvik指令格式"></a>Dalvik指令格式</h3><p>Dalvik汇编代码由一些列Dalvik指令组成，指令语法由指令的位描述和指令格式标识决定。位描述约定如下：</p>
<ul>
<li>每16位的字用空格分开。</li>
<li>每个字母表示4位，每个字母按顺序从高字节到低字节排列，每4位之间可能使用竖线“｜”将不同的内容分开。</li>
<li>顺序采用英文大写字母A～Z表示4位操作码。op表示8位操作码。</li>
<li>Ø表示字段所有位的值为0</li>
</ul>
<p>以指令格式“A|G|op BBBB F|E|D|C”为例进行分析。两个空格把指令分为大小均为16位的三部分，因此，这条指令由三个16位的字组成。<br>第一个16位部分：“A|G|op”，其高8位由“A”和“G”组成，低字节由“op”组成。第二个16位部分由“BBBB”组成，表示一个16位的偏移量。第三个16位部分由“F”“E”“D”“C”四个字节组成，它们分别表示寄存器的参数。</p>
<p>单独使用位标识无法确定一条指令，需要通过指令格式标识来指定指令的格式编码，约定如下：</p>
<ul>
<li>指令格式标识大都由三个字符组成。其中前两个是数字，后一个是字母</li>
<li>第1个数字表示指令由多少个16位的字组成</li>
<li>第2个数字表示指令最多使用的寄存器的个数。特殊标记r用于标识使用的寄存器的范围</li>
<li>第3个字母为类型码，表示指令所使用的额外数据类型</li>
</ul>
<p>以指令格式标识“22x”为例，第1个数字2表示指令由两个16位字组成，第2个数字2表示指令使用两个寄存器，字母x表示没有使用额外的数据。<br>Dalvik指令对语法进行了一些说明，约定如下：</p>
<ul>
<li>每条指令都是从操作码开始的，后面紧跟参数。参数的个数不定，参数之间用逗号分隔</li>
<li>每条指令参数都是从指令的第一部分开始。op位于低8位。高8位可以是一个8位的参数，也可以是两个4位的参数，还可以为空。如果指令超过16位，则将之后的部分依次作为参数</li>
<li>如果参数采用“vX”的形式表示，说明它是一个寄存器，例如v0,v1</li>
<li>如果参数参与“#+X”的形式表示，说明它是一个常量数字</li>
<li>如果参数采用“+X”的形式表示，说明它是一个相对指令的地址偏移量</li>
<li>如果参数采用“kind@X”的形式，说明它是一个常量池索引值。其中“kind”表示常量池的类型，可以是string（字符串常量池索引），type（类型常量池索引），filed（字段常量池索引）或者meth（方法常量池索引）</li>
</ul>
<p>以指令op vAA, string@BBBB为例：使用了一个寄存器参数vAA，附加了一个字符串常量池索引值string@BBBB。这种指令格式表示const-string指令</p>
<h3 id="DEX反汇编工具"><a href="#DEX反汇编工具" class="headerlink" title="DEX反汇编工具"></a>DEX反汇编工具</h3><p>上面使用了dexdump工具，还有一个第三方的<a href="https://bitbucket.org/JesusFreke/smali/downloads/">baksmali</a><br>使用baksmali反汇编Hello.dex,会在当前目录out下面生成<a href="Hello.smali">Hello.smali</a>文件</p>
<div class="highlight-wrap" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">java -jar baksmali-2.5.2.jar d Hello.dex</span><br></pre></td></tr></table></figure></div>
<p>查看Hello.smali文件的foo方法：</p>
<div class="highlight-wrap" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># virtual methods</span></span><br><span class="line">.method public foo(II)I</span><br><span class="line">    .registers 5</span><br><span class="line"></span><br><span class="line">    .prologue</span><br><span class="line">    .line 3</span><br><span class="line">    add-int v0, p1, p2</span><br><span class="line"></span><br><span class="line">    sub-int v1, p1, p2</span><br><span class="line"></span><br><span class="line">    mul-int/2addr v0, v1</span><br><span class="line"></span><br><span class="line">    <span class="built_in">return</span> v0</span><br><span class="line">.end method</span><br></pre></td></tr></table></figure></div>
<p>和使用dexdump反汇编的指令序列一致。寄存器表示dexdump使用的“v”开头，baksmail使用“v”和“p”开头。<br>baksmali提供反汇编的功能，也支持使用smali打包反汇编代码来重新生成DEX文件。</p>
<h3 id="Dalvik寄存器"><a href="#Dalvik寄存器" class="headerlink" title="Dalvik寄存器"></a>Dalvik寄存器</h3><p>Dalvik虚拟机在特点架构的CPU上运行，在设计之初采用ARM架构。ARM架构的CPU本身集成了多个寄存器，Dalvik将部分寄存器映射到ARM寄存器上，还有一部分通过调用栈模拟。</p>
<ul>
<li>Dalvik虚拟机支持多少个寄存器：语法格式op vAAAA, vBBBB其中每个大写字母代表4位。所以最大值为2的16方-1，即为65535.寄存器初始地址为v0,范围为v0~65535</li>
<li>Dalvik虚拟机是如何虚拟使用寄存器的：Dalvik虚拟机为每个进程维护一个调用栈，这个栈的作用之一就是“虚拟”寄存器。每个函数在头部使用.registers来指定使用寄存器的数目，虚拟机执行这个函数时，会根据寄存器的数目分配适当的栈空间，这些空间就是用来存放寄存器的实际值。</li>
</ul>
<h3 id="Dalvik字节码"><a href="#Dalvik字节码" class="headerlink" title="Dalvik字节码"></a>Dalvik字节码</h3><p>Dalvik字节码有自己的类型，方法和字段表示方法，和Dalvik虚拟机指令集一起组成Dalvik汇编代码</p>
<h4 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h4><p>Dalvik字节码分为基本类型和引用类型。Dalvik使用这两种类型表示Java的全部类型。除了对象和数组属于引用类型，其他的Java类型都属于基本类型。<br>Dalvik字节码类型描述符如下表：</p>
<table>
<thead>
<tr>
<th align="left">语法</th>
<th align="left">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="left">v</td>
<td align="left">void,只用于返回值类型</td>
</tr>
<tr>
<td align="left">Z</td>
<td align="left">boolean</td>
</tr>
<tr>
<td align="left">B</td>
<td align="left">byte</td>
</tr>
<tr>
<td align="left">S</td>
<td align="left">short</td>
</tr>
<tr>
<td align="left">C</td>
<td align="left">char</td>
</tr>
<tr>
<td align="left">I</td>
<td align="left">int</td>
</tr>
<tr>
<td align="left">J</td>
<td align="left">long</td>
</tr>
<tr>
<td align="left">F</td>
<td align="left">float</td>
</tr>
<tr>
<td align="left">D</td>
<td align="left">double</td>
</tr>
<tr>
<td align="left">L</td>
<td align="left">Java类类型（汇编语言中用”Lpackage&#x2F;name&#x2F;ObjectName;”表示）</td>
</tr>
<tr>
<td align="left">[</td>
<td align="left">数组类型（汇编语言中用”[I”表示一维int数组）</td>
</tr>
</tbody></table>
<p>每个Dalvik寄存器都是32位。长度小于等于32位的类型，只用一个寄存器就可以存放，对于J，D等64位的类型，要用两个相邻的寄存器来存放</p>
<h4 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h4><p>Dalvik使用方法名，类型参数和返回值来描述一个方法：</p>
<div class="highlight-wrap" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">Lpackage/name/ObjectName;-&gt;MethodName(III)Z</span><br></pre></td></tr></table></figure></div>
<br>
L后面表示Java类类型，MethodName方法，参数位三个int，返回值为一个boolean类型
baksmali生成的方法以.method指令开始，以.end method指令结束，方法类型不同在方法指令前用“#”添加注释.

<h4 id="字段"><a href="#字段" class="headerlink" title="字段"></a>字段</h4><p>字段与方法类似，只是字段没有方法签名域中的参数和返回值，取代它们的是字段类型。格式如下：</p>
<div class="highlight-wrap" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">Lpackage/name/ObjectName;-&gt;FiledName:Ljava/lang/String;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>
<br>
Lpackage/name/ObjectName; ：字段所属类
FiledName：字段名称
Ljava/lang/String; ：字段类型

<p>baksmali生成的字段以.filed开头</p>
<h2 id="Dalvik指令集"><a href="#Dalvik指令集" class="headerlink" title="Dalvik指令集"></a>Dalvik指令集</h2><p>Dalvik指令集使用单字节的指令助记符号。</p>
<h3 id="指令类型"><a href="#指令类型" class="headerlink" title="指令类型"></a>指令类型</h3><p>Dalvik 虚拟机指令类型有如下基本约定:</p>
<ul>
<li>Dalvik 寄存器都是32位的，64位数据使用相邻两个寄存器来存储</li>
<li>常规类型的 32 位运算码未做任何标记,64 位操作码以 -wide 作为后缀</li>
<li>一般指令中目标寄存器在前，源寄存器在后</li>
<li>寄存器最大数量为 65536 个</li>
<li>一个大写字母表示4位。如vA 表示前16个寄存器之内，vBB表示前256个寄存器之内，vCCCC表示前65536个寄存器之内</li>
</ul>
<p>下表列出所有指令其中表头解释如下：</p>
<ul>
<li>操作码 ：十六进制，范围 00 - ff</li>
<li>格式码 ：一般三个字符，前两个为数字，最后为字母。第一个数字表示指令有多少个 16 位的字组成。第二个数字表示指令最多使用的寄存器个数。第三个字母是类型码，表示指令所使用的额外数据的类型。</li>
<li>语法 ：助记符，smali 语法中就这么表示</li>
<li>说明 : 指令解释</li>
</ul>
<details>
<summary>下表列出00-ff操作码相关的指令</summary>

<table>
<thead>
<tr>
<th>操作码</th>
<th>格式码</th>
<th>语法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>00</td>
<td>10x</td>
<td>nop</td>
<td>空指令</td>
</tr>
<tr>
<td>01</td>
<td>12x</td>
<td>move vA, vB</td>
<td>将寄存器 vB 的内容赋给寄存器 vA</td>
</tr>
<tr>
<td>02</td>
<td>22x</td>
<td>move&#x2F;from16 vAA, vBBBB</td>
<td>将寄存器 vBBBB 的内容赋给寄存器 vAA。vAA 范围是 0-255，vBBBB 范围是 0-65535</td>
</tr>
<tr>
<td>03</td>
<td>32x</td>
<td>move&#x2F;16 vAAAA, vBBBB</td>
<td>将寄存器 vBBBB 的内容赋给寄存器 vAAAA。两个寄存器范围都是 0-65535</td>
</tr>
<tr>
<td>04</td>
<td>12x</td>
<td>move-wide vA, vB</td>
<td>将寄存器对 vB 的内容赋给寄存器对 vA</td>
</tr>
<tr>
<td>05</td>
<td>22x</td>
<td>move-wide&#x2F;from16 vAA, vBBBB</td>
<td>将寄存器对 vBBBB 的内容赋给寄存器对 vAA</td>
</tr>
<tr>
<td>06</td>
<td>32x</td>
<td>move-wide&#x2F;16 vAAAA, vBBBB</td>
<td>将寄存器对 vBBBB 的内容赋给寄存器对 vAAAA</td>
</tr>
<tr>
<td>07</td>
<td>12x</td>
<td>move-object vA, vB</td>
<td>将寄存器 vB 中的对象引用赋给寄存去 vA</td>
</tr>
<tr>
<td>08</td>
<td>22x</td>
<td>move-object&#x2F;from16 vAA, vBBBB</td>
<td>将寄存器 vBBBB 中的对象引用赋给寄存对 vAA</td>
</tr>
<tr>
<td>09</td>
<td>32x</td>
<td>move-object&#x2F;16 vAAAA, vBBBB</td>
<td>将寄存器 vBBBB 中的对象引用赋给寄存去 vAAAA</td>
</tr>
<tr>
<td>0a</td>
<td>11x</td>
<td>move-result vAA</td>
<td>将上一个 invoke-kind 指令的单字非对象结果存入寄存器 vAA</td>
</tr>
<tr>
<td>0b</td>
<td>11x</td>
<td>move-result-wide vAA</td>
<td>将上一个 invoke-kind 指令的双字非对象结果存入寄存器 vAA，vAA+1</td>
</tr>
<tr>
<td>0c</td>
<td>11x</td>
<td>move-result-object vAA</td>
<td>将上一个 invoke-kind 指令的对象结果存入寄存器 vAA</td>
</tr>
<tr>
<td>0d</td>
<td>11x</td>
<td>move-exception vAA</td>
<td>将方法执行过程中抛出的异常存入寄存器 vAA</td>
</tr>
<tr>
<td>0e</td>
<td>10x</td>
<td>return-void</td>
<td>返回 void</td>
</tr>
<tr>
<td>0f</td>
<td>11x</td>
<td>return vAA</td>
<td>返回 32 位非对象值</td>
</tr>
<tr>
<td>10</td>
<td>11x</td>
<td>return-wide vAA</td>
<td>返回 64 位非对象值</td>
</tr>
<tr>
<td>11</td>
<td>11x</td>
<td>return-object vAA</td>
<td>返回对象引用</td>
</tr>
<tr>
<td>12</td>
<td>11n</td>
<td>const&#x2F;4 vA, #+B</td>
<td>将给定的 4 位字面值符号扩展为 32 位之后赋给寄存器 vA</td>
</tr>
<tr>
<td>13</td>
<td>21s</td>
<td>const&#x2F;16 vAA, #+BBBB</td>
<td>将给定的 16 位字面值符号扩展为 32 位之后赋给寄存器 vAA</td>
</tr>
<tr>
<td>14</td>
<td>31i</td>
<td>const vAA, #+BBBB</td>
<td>将给定的字面值赋给寄存器 vAA</td>
</tr>
<tr>
<td>15</td>
<td>21h</td>
<td>const&#x2F;high16 vAA, #+BBBB0000</td>
<td>将给定的字面值右零扩展为 32 位之后赋给寄存器 vAA,vAA+1</td>
</tr>
<tr>
<td>16</td>
<td>21s</td>
<td>const-wide&#x2F;16 vAA, #+BBBB</td>
<td>将给定的 16 位字面值符号扩展为 64 位之后赋给寄存器 vAA,vAA+1</td>
</tr>
<tr>
<td>17</td>
<td>31i</td>
<td>const-wide&#x2F;32 vAA, #+BBBBBBBB</td>
<td>将给定的 32 位字面值符号扩展为 64 位之后赋给寄存器 vAA,vAA+1</td>
</tr>
<tr>
<td>18</td>
<td>51l</td>
<td>const-wide vAA, #+BBBBBBBBBBBBBBBB</td>
<td>将给定的 64 位字面值赋给寄存器 vAA,vAA+1</td>
</tr>
<tr>
<td>19</td>
<td>21h</td>
<td>const-wide&#x2F;high16 vAA, #+vBBBB000000000000</td>
<td>将给定的 16 位字面值右零扩展为 64 位之后赋给寄存器对 vAA</td>
</tr>
<tr>
<td>1a</td>
<td>21c</td>
<td>const-string vAA, string@BBBB</td>
<td>将字符串索引 BBBB 指向的字符串引用赋给寄存器 vAA</td>
</tr>
<tr>
<td>1b</td>
<td>31c</td>
<td>const-string&#x2F;jumbo vAA, string@BBBBBBBB</td>
<td>将字符串索引 BBBBBBBB 指向的字符串引用赋给寄存器 vAA</td>
</tr>
<tr>
<td>1c</td>
<td>21c</td>
<td>const-class vAA, type@BBBB</td>
<td>将类型索引 BBBB 指向的类引用赋给寄存器 vAA</td>
</tr>
<tr>
<td>1d</td>
<td>11x</td>
<td>monitor-enter vAA</td>
<td>获取寄存器 vAA 中对象的监视锁</td>
</tr>
<tr>
<td>1e</td>
<td>11x</td>
<td>monitor-exit vAA</td>
<td>释放寄存器 vAA 中对象的监视锁</td>
</tr>
<tr>
<td>1f</td>
<td>21c</td>
<td>check-cast vAA type@BBBB</td>
<td>将寄存器 vAA 中的对象引用转化为 type@BBBB 指定的类型，若失败抛出 ClassCastException</td>
</tr>
<tr>
<td>20</td>
<td>22c</td>
<td>instance-of vA, vB type@CCCC</td>
<td>判断寄存器 vB 中的对象引用是否为类型 type@CCCC 的实例。如果是给寄存器 vA 赋值为 1，否则赋值为 0</td>
</tr>
<tr>
<td>21</td>
<td>12x</td>
<td>array-length vA, vB</td>
<td>获取寄存器 vB 中的数组的长度并赋给寄存器 vA</td>
</tr>
<tr>
<td>22</td>
<td>21c</td>
<td>new-instance vAA, type@vBBBB</td>
<td>构建指定类型 type@BBBB 的实例对象，并将对象引用赋给寄存器 vAA</td>
</tr>
<tr>
<td>23</td>
<td>22c</td>
<td>new-array vA, vB, type@CCCC</td>
<td>构建指定类型 type@CCCC 和指定大小 vB 的数组，并将数组引用赋给寄存器 vA</td>
</tr>
<tr>
<td>24</td>
<td>35c</td>
<td>filled-new-array {vC,vD,vE,vF,vG} type@vBBBB</td>
<td>构建指定类型 type@BBBB 和指定大小的数组，并使用提供的内容 vC-vG 填充数组。由于数组内容是给定的，所以无需再使用一个寄存器 vA 指定数组大小</td>
</tr>
<tr>
<td>25</td>
<td>3rc</td>
<td>filled-new-array&#x2F;range {vCCCC..vNNNN} type@BBBB</td>
<td>同上，区别是使用一定范围内的寄存器内容来填充数组，数组大小为 N-C+1</td>
</tr>
<tr>
<td>26</td>
<td>31t</td>
<td>fill-array-data vAA, +BBBB</td>
<td>使用给定数据 BBBB 填充寄存器 vAA 存储的数组，只能是基本类型数组。BBBB 有特定的格式</td>
</tr>
<tr>
<td>27</td>
<td>11x</td>
<td>throw vAA</td>
<td>抛出寄存器 vAA 指定的异常</td>
</tr>
<tr>
<td>28</td>
<td>10t</td>
<td>goto +AA</td>
<td>无条件跳转至指定偏移处，偏移量 AA 为 8 位</td>
</tr>
<tr>
<td>29</td>
<td>20t</td>
<td>goto&#x2F;16 +AAAA</td>
<td>无条件跳转至指定偏移处，偏移量 AAAA 为 16 位</td>
</tr>
<tr>
<td>2a</td>
<td>30t</td>
<td>goto&#x2F;32 +AAAAAAAA</td>
<td>无条件跳转至指定偏移处，偏移量 AAAAAAAA 为 32 位</td>
</tr>
<tr>
<td>2b</td>
<td>31t</td>
<td>packed-switch vAA, +BBBBBBBB</td>
<td>寄存器 vAA 存储的是是希望跳转的偏移量，BBBBBBBB 是一个偏移量表。基于偏移量表查找匹配项，如果存在则跳转，不存在跳转到下一指令</td>
</tr>
<tr>
<td>2c</td>
<td>31t</td>
<td>sparse-switch vAA, +BBBBBBBB</td>
<td></td>
</tr>
<tr>
<td>2d</td>
<td>23x</td>
<td>cmpl-float vAA, vBB, vCC</td>
<td>比较两个单精度浮点数。如果寄存器 vBB 的值大于寄存器 vCC 的值，结果为 -1；如果等于，结果为 0；如果小于，结果为 1。NaN 比较返回 -1。结果赋给寄存器 vAA</td>
</tr>
<tr>
<td>2e</td>
<td>23x</td>
<td>cmpg-float vAA, vBB, vCC</td>
<td>比较两个单精度浮点数。如果寄存器 vBB 的值大于寄存器 vCC 的值，结果为 1；如果等于，结果为 0；如果小于，结果为 -1。NaN 比较返回 1。结果赋给寄存器 vAA</td>
</tr>
<tr>
<td>2f</td>
<td>23x</td>
<td>cmpl-double vAA, vBB, vCC</td>
<td>比较两个双精度浮点数。如果寄存器 vBB 的值大于寄存器 vCC 的值，结果为 -1；如果等于，结果为 0；如果小于，结果为 1。NaN 比较返回 -1。结果赋给寄存器 vAA</td>
</tr>
<tr>
<td>30</td>
<td>23x</td>
<td>cmpg-double vAA, vBB, vCC</td>
<td>比较两个双精度浮点数。如果寄存器 vBB 的值大于寄存器 vCC 的值，结果为 1；如果等于，结果为 0；如果小于，结果为 -1。NaN 比较返回 1。结果赋给寄存器 vAA</td>
</tr>
<tr>
<td>31</td>
<td>23x</td>
<td>cmp-long vAA, vBB, vCC</td>
<td>比较两个长整型数。如果寄存器 vBB 的值大于寄存器 vCC 的值，结果为 1；如果等于，结果为 0；如果小于，结果为 -1。结果赋给寄存器 vAA</td>
</tr>
<tr>
<td>32</td>
<td>22t</td>
<td>if-eq vA, vB, +CCCC</td>
<td>如果寄存器 vA 的值等于 vB 的值，则跳转到指定偏移处，偏移量为 CCCC</td>
</tr>
<tr>
<td>33</td>
<td>22t</td>
<td>if-ne vA, vB, +CCCC</td>
<td>如果寄存器 vA 的值不等于 vB 的值，则跳转到指定偏移处，偏移量为 CCCC</td>
</tr>
<tr>
<td>34</td>
<td>22t</td>
<td>if-lt vA, vB, +CCCC</td>
<td>如果寄存器 vA 的值小于 vB 的值，则跳转到指定偏移处，偏移量为 CCCC</td>
</tr>
<tr>
<td>35</td>
<td>22t</td>
<td>if-ge vA, vB, +CCCC</td>
<td>如果寄存器 vA 的值大于等于 vB 的值，则跳转到指定偏移处，偏移量为 CCCC</td>
</tr>
<tr>
<td>36</td>
<td>22t</td>
<td>if-gt vA, vB, +CCCC</td>
<td>如果寄存器 vA 的值大于 vB 的值，则跳转到指定偏移处，偏移量为 CCCC</td>
</tr>
<tr>
<td>37</td>
<td>22t</td>
<td>if-le vA, vB, +CCCC</td>
<td>如果寄存器 vA 的值小于等于 vB 的值，则跳转到指定偏移处，偏移量为 CCCC</td>
</tr>
<tr>
<td>38</td>
<td>21t</td>
<td>if-eqz vAA, +BBBB</td>
<td>如果寄存器 vAA 的值等于 0，则跳转到指定偏移处，偏移量为 BBBB</td>
</tr>
<tr>
<td>39</td>
<td>21t</td>
<td>if-nez vAA, +BBBB</td>
<td>如果寄存器 vAA 的值不等于 0，则跳转到指定偏移处，偏移量为 BBBB</td>
</tr>
<tr>
<td>3a</td>
<td>21t</td>
<td>if-ltz vAA, +BBBB</td>
<td>如果寄存器 vAA 的值小于 0，则跳转到指定偏移处，偏移量为 BBBB</td>
</tr>
<tr>
<td>3b</td>
<td>21t</td>
<td>if-gez vAA, +BBBB</td>
<td>如果寄存器 vAA 的值大于等于 0，则跳转到指定偏移处，偏移量为 BBBB</td>
</tr>
<tr>
<td>3c</td>
<td>21t</td>
<td>if-gtz vAA, +BBBB</td>
<td>如果寄存器 vAA 的值大于 0，则跳转到指定偏移处，偏移量为 BBBB</td>
</tr>
<tr>
<td>3d</td>
<td>21t</td>
<td>if-lez vAA, +BBBB</td>
<td>如果寄存器 vAA 的值小于等于 0，则跳转到指定偏移处，偏移量为 BBBB</td>
</tr>
<tr>
<td>3e</td>
<td>10x</td>
<td>unused</td>
<td></td>
</tr>
<tr>
<td>3f</td>
<td>10x</td>
<td>unused</td>
<td></td>
</tr>
<tr>
<td>40</td>
<td>10x</td>
<td>unused</td>
<td></td>
</tr>
<tr>
<td>41</td>
<td>10x</td>
<td>unused</td>
<td></td>
</tr>
<tr>
<td>42</td>
<td>10x</td>
<td>unused</td>
<td></td>
</tr>
<tr>
<td>43</td>
<td>10x</td>
<td>unused</td>
<td></td>
</tr>
<tr>
<td>44</td>
<td>23x</td>
<td>aget vAA, vBB, vCC</td>
<td>获取寄存器 vBB 存储的数组指定索引处的元素并赋给寄存器 vAA。寄存器 vCC 的值为指定索引</td>
</tr>
<tr>
<td>45</td>
<td>23x</td>
<td>aget-wide vAA, vBB, vCC</td>
<td>获取寄存器 vBB 存储的数组指定索引处的元素(64 位)并赋给寄存器对 vAA。寄存器 vCC 的值为指定索引</td>
</tr>
<tr>
<td>46</td>
<td>23x</td>
<td>aget-object vAA, vBB, vCC</td>
<td>获取寄存器 vBB 存储的对象类型数组指定索引处的元素并赋给寄存器 vAA。寄存器 vCC 的值为指定索引</td>
</tr>
<tr>
<td>47</td>
<td>23x</td>
<td>aget-boolean vAA, vBB, vCC</td>
<td>获取寄存器 vBB 存储的布尔类型数组指定索引处的元素并赋给寄存器 vAA。寄存器 vCC 的值为指定索引</td>
</tr>
<tr>
<td>48</td>
<td>23x</td>
<td>aget-byte vAA, vBB, vCC</td>
<td>获取寄存器 vBB 存储的 byte 类型数组指定索引处的元素并赋给寄存器 vAA。寄存器 vCC 的值为指定索引</td>
</tr>
<tr>
<td>49</td>
<td>23x</td>
<td>aget-char vAA, vBB, vCC</td>
<td>获取寄存器 vBB 存储的 char 类型数组指定索引处的元素并赋给寄存器 vAA。寄存器 vCC 的值为指定索引</td>
</tr>
<tr>
<td>4a</td>
<td>23x</td>
<td>aget-short vAA, vBB, vCC</td>
<td>获取寄存器 vBB 存储的 short 类型数组指定索引处的元素并赋给寄存器 vAA。寄存器 vCC 的值为指定索引</td>
</tr>
<tr>
<td>4b</td>
<td>23x</td>
<td>aput vAA, vBB, vCC</td>
<td>将寄存器 vAA 的值赋给寄存器 vBB 存储的数组的指定索引处。寄存器 vCC 存储的值为指定索引</td>
</tr>
<tr>
<td>4c</td>
<td>23x</td>
<td>aput-wide vAA, vBB, vCC</td>
<td>将寄存器对 vAA 的值(64 位)赋给寄存器 vBB 存储的数组的指定索引处。寄存器 vCC 存储的值为指定索引</td>
</tr>
<tr>
<td>4d</td>
<td>23x</td>
<td>aput-object vAA, vBB, vCC</td>
<td>将寄存器 vAA 存储的对象赋给寄存器 vBB 存储的数组的指定索引处。寄存器 vCC 存储的值为指定索引</td>
</tr>
<tr>
<td>4e</td>
<td>23x</td>
<td>aput-boolean vAA, vBB, vCC</td>
<td>将寄存器 vAA 存储的布尔值赋给寄存器 vBB 存储的数组的指定索引处。寄存器 vCC 存储的值为指定索引</td>
</tr>
<tr>
<td>4f</td>
<td>23x</td>
<td>aput-byte vAA, vBB, vCC</td>
<td>将寄存器 vAA 存储的 byte 值赋给寄存器 vBB 存储的数组的指定索引处。寄存器 vCC 存储的值为指定索引</td>
</tr>
<tr>
<td>50</td>
<td>23x</td>
<td>aput-char vAA, vBB, vCC</td>
<td>将寄存器 vAA 存储的 char 值赋给寄存器 vBB 存储的数组的指定索引处。寄存器 vCC 存储的值为指定索引</td>
</tr>
<tr>
<td>51</td>
<td>23x</td>
<td>aput-short vAA, vBB, vCC</td>
<td>将寄存器 vAA 存储的 short 值赋给寄存器 vBB 存储的数组的指定索引处。寄存器 vCC 存储的值为指定索引</td>
</tr>
<tr>
<td>52</td>
<td>22c</td>
<td>iget vA, vB, field@CCCC</td>
<td>获取寄存器 vB 存储的实例的字段，并存入寄存器 vA。字段类型是 CCCC</td>
</tr>
<tr>
<td>53</td>
<td>22c</td>
<td>iget-wide vA, vB, field@CCCC</td>
<td>获取寄存器 vB 存储的实例的字段，并存入寄存器对 vA。字段类型是 CCCC</td>
</tr>
<tr>
<td>54</td>
<td>22c</td>
<td>iget-object  vA, vB, field@CCCC</td>
<td>获取寄存器 vB 存储的实例的对象类型字段，并存入寄存器 vA。字段类型是 CCCC</td>
</tr>
<tr>
<td>55</td>
<td>22c</td>
<td>iget-boolean vA, vB, field@CCCC</td>
<td>获取寄存器 vB 存储的实例的 boolean 类型字段，并存入寄存器 vA。字段类型是 CCCC</td>
</tr>
<tr>
<td>56</td>
<td>22c</td>
<td>iget-byte vA, vB, field@CCCC</td>
<td>获取寄存器 vB 存储的实例的 byte 类型字段，并存入寄存器 vA。字段类型是 CCCC</td>
</tr>
<tr>
<td>57</td>
<td>22c</td>
<td>iget-char vA, vB, field@CCCC</td>
<td>获取寄存器 vB 存储的实例的 char 类型字段，并存入寄存器 vA。字段类型是 CCCC</td>
</tr>
<tr>
<td>58</td>
<td>22c</td>
<td>iget-short vA, vB, field@CCCC</td>
<td>获取寄存器 vB 存储的实例的 short 类型字段，并存入寄存器 vA。字段类型是 CCCC</td>
</tr>
<tr>
<td>59</td>
<td>22c</td>
<td>iput vA, vB, field@CCCC</td>
<td>将寄存器 vA 存储的值赋给寄存器 vB 存储的实例的字段。字段类型是 CCCC</td>
</tr>
<tr>
<td>5a</td>
<td>22c</td>
<td>iput-wide vA, vB, field@CCCC</td>
<td>将寄存器对 vA 存储的值(64位)赋给寄存器 vB 存储的实例的字段。字段类型是 CCCC</td>
</tr>
<tr>
<td>5b</td>
<td>22c</td>
<td>iput-object vA, vB, field@CCCC</td>
<td>将寄存器 vA 存储的对象类型值赋给寄存器 vB 存储的实例的字段。字段类型是 CCCC</td>
</tr>
<tr>
<td>5c</td>
<td>22c</td>
<td>iput-boolean vA, vB, field@CCCC</td>
<td>将寄存器 vA 存储的 boolean 类型值赋给寄存器 vB 存储的实例的字段。字段类型是 CCCC</td>
</tr>
<tr>
<td>5d</td>
<td>22c</td>
<td>iput-byte vA, vB, field@CCCC</td>
<td>将寄存器 vA 存储的 byte 类型值赋给寄存器 vB 存储的实例的字段。字段类型是 CCCC</td>
</tr>
<tr>
<td>5e</td>
<td>22c</td>
<td>iput-char vA, vB, field@CCCC</td>
<td>将寄存器 vA 存储的 char 类型值赋给寄存器 vB 存储的实例的字段。字段类型是 CCCC</td>
</tr>
<tr>
<td>5f</td>
<td>22c</td>
<td>iput-short vA, vB, field@CCCC</td>
<td>将寄存器 vA 存储的 short 类型值赋给寄存器 vB 存储的实例的字段。字段类型是 CCCC</td>
</tr>
<tr>
<td>60</td>
<td>21c</td>
<td>sget vA, vB, field@CCCC</td>
<td>获取寄存器 vB 存储的实例的静态字段，并存入寄存器 vA。字段类型是 CCCC</td>
</tr>
<tr>
<td>61</td>
<td>21c</td>
<td>sget-wide vA, vB, field@CCCC</td>
<td>获取寄存器 vB 存储的实例的静态字段，并存入寄存器对 vA。字段类型是 CCCC</td>
</tr>
<tr>
<td>62</td>
<td>21c</td>
<td>sget-object  vA, vB, field@CCCC</td>
<td>获取寄存器 vB 存储的实例的对象类型静态字段，并存入寄存器 vA。字段类型是 CCCC</td>
</tr>
<tr>
<td>63</td>
<td>21c</td>
<td>sget-boolean vA, vB, field@CCCC</td>
<td>获取寄存器 vB 存储的实例的 boolean 类型静态字段，并存入寄存器 vA。字段类型是 CCCC</td>
</tr>
<tr>
<td>64</td>
<td>21c</td>
<td>sget-byte vA, vB, field@CCCC</td>
<td>获取寄存器 vB 存储的实例的 byte 类型静态字段，并存入寄存器 vA。字段类型是 CCCC</td>
</tr>
<tr>
<td>65</td>
<td>21c</td>
<td>sget-char vA, vB, field@CCCC</td>
<td>获取寄存器 vB 存储的实例的 char 类型静态字段，并存入寄存器 vA。字段类型是 CCCC</td>
</tr>
<tr>
<td>66</td>
<td>21c</td>
<td>sget-short vA, vB, field@CCCC</td>
<td>获取寄存器 vB 存储的实例的 short 类型静态字段，并存入寄存器 vA。字段类型是 CCCC</td>
</tr>
<tr>
<td>67</td>
<td>21c</td>
<td>sput vA, vB, field@CCCC</td>
<td>将寄存器 vA 存储的值赋给寄存器 vB 存储的实例的静态字段。字段类型是 CCCC</td>
</tr>
<tr>
<td>68</td>
<td>21c</td>
<td>sput-wide vA, vB, field@CCCC</td>
<td>将寄存器对 vA 存储的值(64位)赋给寄存器 vB 存储的实例的静态字段。字段类型是 CCCC</td>
</tr>
<tr>
<td>69</td>
<td>21c</td>
<td>sput-object vA, vB, field@CCCC</td>
<td>将寄存器 vA 存储的对象类型值赋给寄存器 vB 存储的实例的静态字段。字段类型是 CCCC</td>
</tr>
<tr>
<td>6a</td>
<td>21c</td>
<td>sput-boolean vA, vB, field@CCCC</td>
<td>将寄存器 vA 存储的 boolean 类型值赋给寄存器 vB 存储的实例的静态字段。字段类型是 CCCC</td>
</tr>
<tr>
<td>6b</td>
<td>21c</td>
<td>sput-byte vA, vB, field@CCCC</td>
<td>将寄存器 vA 存储的 byte 类型值赋给寄存器 vB 存储的实例的静态字段。字段类型是 CCCC</td>
</tr>
<tr>
<td>6c</td>
<td>21c</td>
<td>sput-char vA, vB, field@CCCC</td>
<td>将寄存器 vA 存储的 char 类型值赋给寄存器 vB 存储的实例的静态字段。字段类型是 CCCC</td>
</tr>
<tr>
<td>6d</td>
<td>21c</td>
<td>sput-short vA, vB, field@CCCC</td>
<td>将寄存器 vA 存储的 short 类型值赋给寄存器 vB 存储的实例的静态字段。字段类型是 CCCC</td>
</tr>
<tr>
<td>6e</td>
<td>35c</td>
<td>invoke-virtual {vC,vD,vE,vF,vG} meth@BBBB</td>
<td>调用实例的虚方法，C~G 是参数寄存器</td>
</tr>
<tr>
<td>6f</td>
<td>35c</td>
<td>invoke-super {vC,vD,vE,vF,vG} meth@BBBB</td>
<td>调用实例的父类方法，C~G 是参数寄存器</td>
</tr>
<tr>
<td>70</td>
<td>35c</td>
<td>invoke-direct {vC,vD,vE,vF,vG} meth@BBBB</td>
<td>调用实例的 private 方法或者构造函数，C~G 是参数寄存器</td>
</tr>
<tr>
<td>71</td>
<td>35c</td>
<td>invoke-static {vC,vD,vE,vF,vG} meth@BBBB</td>
<td>调用实例的 static 方法，C~G 是参数寄存器</td>
</tr>
<tr>
<td>72</td>
<td>35c</td>
<td>invoke-interface {vC,vD,vE,vF,vG} meth@BBBB</td>
<td>调用实例的接口方法，C~G 是参数寄存器</td>
</tr>
<tr>
<td>73</td>
<td>10x</td>
<td>unused</td>
<td></td>
</tr>
<tr>
<td>74</td>
<td>3rc</td>
<td>invoke-virtual&#x2F;range {vCCCC..vNNNN} meth@BBBB</td>
<td>同上。只是参数寄存器表示方式不一样。这里直接使用 vCCCC 到 vNNNN 之间的寄存器，而不是单独指定每个寄存器</td>
</tr>
<tr>
<td>75</td>
<td>3rc</td>
<td>invoke-super&#x2F;range {vCCCC..vNNNN} meth@BBBB</td>
<td></td>
</tr>
<tr>
<td>76</td>
<td>3rc</td>
<td>invoke-direct&#x2F;range {vCCCC..vNNNN} meth@BBBB</td>
<td></td>
</tr>
<tr>
<td>77</td>
<td>3rc</td>
<td>invoke-static&#x2F;range {vCCCC..vNNNN} meth@BBBB</td>
<td></td>
</tr>
<tr>
<td>78</td>
<td>3rc</td>
<td>invoke-interface&#x2F;range {vCCCC..vNNNN} meth@BBBB</td>
<td></td>
</tr>
<tr>
<td>79</td>
<td>10x</td>
<td>unused</td>
<td></td>
</tr>
<tr>
<td>7a</td>
<td>10x</td>
<td>unused</td>
<td></td>
</tr>
<tr>
<td>7b</td>
<td>12x</td>
<td>neg-int vA, vB</td>
<td>对寄存器 vB 存储的整型数求补并存入寄存器 vA</td>
</tr>
<tr>
<td>7c</td>
<td>12x</td>
<td>not-int vA, vB</td>
<td>对寄存器 vB 存储的整型数求反并存入寄存器 vA</td>
</tr>
<tr>
<td>7d</td>
<td>12x</td>
<td>neg-long vA, vB</td>
<td>对寄存器对 vB 存储的长整型数求补并存入寄存器对 vA</td>
</tr>
<tr>
<td>7e</td>
<td>12x</td>
<td>not-long vA, vB</td>
<td>对寄存器对 vB 存储的长整型数求反并存入寄存器对 vA</td>
</tr>
<tr>
<td>7f</td>
<td>12x</td>
<td>neg-float vA, vB</td>
<td>对寄存器 vB 存储的单精度浮点数求补并存入寄存器 vA</td>
</tr>
<tr>
<td>80</td>
<td>12x</td>
<td>neg-double vA, vB</td>
<td>对寄存器对 vB 存储的双精度浮点数求补并存入寄存器对 vA</td>
</tr>
<tr>
<td>81</td>
<td>12x</td>
<td>int-to-long vA, vB</td>
<td>将寄存器 vB 中的整型数转换为长整型数，并存入寄存器对 vA</td>
</tr>
<tr>
<td>82</td>
<td>12x</td>
<td>int-to-float vA, vB</td>
<td>将寄存器 vB 中的整型数转换为单精度浮点数，并存入寄存器 vA</td>
</tr>
<tr>
<td>83</td>
<td>12x</td>
<td>int-to-double vA, vB</td>
<td>将寄存器 vB 中的整型数转换为双精度浮点数，并存入寄存器对 vA</td>
</tr>
<tr>
<td>84</td>
<td>12x</td>
<td>long-to-int vA, vB</td>
<td>将寄存器对 vB 中的长整型数转换为整型数，并存入寄存器 vA</td>
</tr>
<tr>
<td>85</td>
<td>12x</td>
<td>long-to-float vA, vB</td>
<td>将寄存器对 vB 中的长整型数转换为单精度浮点数，并存入寄存器 vA</td>
</tr>
<tr>
<td>86</td>
<td>12x</td>
<td>long-to-double vA, vB</td>
<td>将寄存器对 vB 中的长整型数转换为双精度浮点数，并存入寄存器对 vA</td>
</tr>
<tr>
<td>87</td>
<td>12x</td>
<td>float-to-int vA, vB</td>
<td>将寄存器 vB 中的单精度浮点数转换为整型数，并存入寄存器 vA</td>
</tr>
<tr>
<td>88</td>
<td>12x</td>
<td>float-to-long vA, vB</td>
<td>将寄存器 vB 中的单精度浮点数转换为长整型数，并存入寄存器对 vA</td>
</tr>
<tr>
<td>89</td>
<td>12x</td>
<td>float-to-double vA, vB</td>
<td>将寄存器 vB 中的单精度浮点数转换为双精度浮点数，并存入寄存器 vA</td>
</tr>
<tr>
<td>8a</td>
<td>12x</td>
<td>double-to-int vA, vB</td>
<td>将寄存器对 vB 中的双精度浮点数转换为整型数，并存入寄存器 vA</td>
</tr>
<tr>
<td>8b</td>
<td>12x</td>
<td>double-to-long vA, vB</td>
<td>将寄存器对 vB 中的双精度浮点数转换为长整型数，并存入寄存器对 vA</td>
</tr>
<tr>
<td>8c</td>
<td>12x</td>
<td>double-to-float vA, vB</td>
<td>将寄存器对 vB 中的双精度浮点数转换为单精度浮点数，并存入寄存器 vA</td>
</tr>
<tr>
<td>8d</td>
<td>12x</td>
<td>int-to-byte vA, vB</td>
<td>将寄存器对 vB 中的整型数转换为 byte，并存入寄存器 vA</td>
</tr>
<tr>
<td>8e</td>
<td>12x</td>
<td>int-to-char vA, vB</td>
<td>将寄存器对 vB 中的整型数转换为 char，并存入寄存器 vA</td>
</tr>
<tr>
<td>8f</td>
<td>12x</td>
<td>int-to-short vA, vB</td>
<td>将寄存器对 vB 中的整型数转换为 short，并存入寄存器 vA</td>
</tr>
<tr>
<td>90</td>
<td>23x</td>
<td>add-int vAA, vBB, vCC</td>
<td>将寄存器 vBB 中的整型数加上寄存器 vCC 中的整型数，结果存入寄存器 vAA</td>
</tr>
<tr>
<td>91</td>
<td>23x</td>
<td>sub-int vAA, vBB, vCC</td>
<td>将寄存器 vBB 中的整型数减去寄存器 vCC 中的整型数，结果存入寄存器 vAA</td>
</tr>
<tr>
<td>92</td>
<td>23x</td>
<td>mul-int vAA, vBB, vCC</td>
<td>将寄存器 vBB 中的整型数乘以寄存器 vCC 中的整型数，结果存入寄存器 vAA</td>
</tr>
<tr>
<td>93</td>
<td>23x</td>
<td>div-int vAA, vBB, vCC</td>
<td>将寄存器 vBB 中的整型数除以寄存器 vCC 中的整型数，结果存入寄存器 vAA</td>
</tr>
<tr>
<td>94</td>
<td>23x</td>
<td>rem-int vAA, vBB, vCC</td>
<td>将寄存器 vBB 中的整型数和寄存器 vCC 中的整型数进行模运算，结果存入寄存器 vAA</td>
</tr>
<tr>
<td>95</td>
<td>23x</td>
<td>and-int vAA, vBB, vCC</td>
<td>将寄存器 vBB 中的整型数和寄存器 vCC 中的整型数进行与运算，结果存入寄存器 vAA</td>
</tr>
<tr>
<td>96</td>
<td>23x</td>
<td>or-int vAA, vBB, vCC</td>
<td>将寄存器 vBB 中的整型数和寄存器 vCC 中的整型数进行或运算，结果存入寄存器 vAA</td>
</tr>
<tr>
<td>97</td>
<td>23x</td>
<td>xor-int vAA, vBB, vCC</td>
<td>将寄存器 vBB 中的整型数和寄存器 vCC 中的整型数进行异或运算，结果存入寄存器 vAA</td>
</tr>
<tr>
<td>98</td>
<td>23x</td>
<td>shl-int vAA, vBB, vCC</td>
<td>将寄存器 vBB 中的有符号数左移 vCC 位，结果存入寄存器 vAA</td>
</tr>
<tr>
<td>99</td>
<td>23x</td>
<td>shr-int vAA, vBB, vCC</td>
<td>将寄存器 vBB 中的有符号数右移 vCC 位，结果存入寄存器 vAA</td>
</tr>
<tr>
<td>9a</td>
<td>23x</td>
<td>ushr-int vAA, vBB, vCC</td>
<td>将寄存器 vBB 中的无符号数右移 vCC 位，结果存入寄存器 vAA</td>
</tr>
<tr>
<td>9b</td>
<td>23x</td>
<td>add-long vAA, vBB, vCC</td>
<td>将寄存器对 vBB 中的长整型数加上寄存器对 vCC 中的长整型数，结果存入寄存器对 vAA</td>
</tr>
<tr>
<td>9c</td>
<td>23x</td>
<td>sub-long vAA, vBB, vCC</td>
<td>将寄存器对 vBB 中的长整型数减去寄存器对 vCC 中的长整型数，结果存入寄存器对 vAA</td>
</tr>
<tr>
<td>9d</td>
<td>23x</td>
<td>mul-long vAA, vBB, vCC</td>
<td>将寄存器对 vBB 中的长整型数乘以寄存器对 vCC 中的长整型数，结果存入寄存器对 vAA</td>
</tr>
<tr>
<td>9e</td>
<td>23x</td>
<td>div-long vAA, vBB, vCC</td>
<td>将寄存器对 vBB 中的长整型数除以寄存器对 vCC 中的长整型数，结果存入寄存器对 vAA</td>
</tr>
<tr>
<td>9f</td>
<td>23x</td>
<td>rem-long vAA, vBB, vCC</td>
<td>将寄存器对 vBB 中的长整型数和寄存器对 vCC 中的长整型数进行模运算，结果存入寄存器对 vAA</td>
</tr>
<tr>
<td>a0</td>
<td>23x</td>
<td>and-long vAA, vBB, vCC</td>
<td>将寄存器对 vBB 中的长整型数和寄存器对 vCC 中的长整型数进行与运算，结果存入寄存器对 vAA</td>
</tr>
<tr>
<td>a1</td>
<td>23x</td>
<td>or-long vAA, vBB, vCC</td>
<td>将寄存器对 vBB 中的长整型数和寄存器对 vCC 中的长整型数进行或运算，结果存入寄存器对 vAA</td>
</tr>
<tr>
<td>a2</td>
<td>23x</td>
<td>xor-long vAA, vBB, vCC</td>
<td>将寄存器对 vBB 中的长整型数和寄存器对 vCC 中的长整型数进行异或运算，结果存入寄存器对 vAA</td>
</tr>
<tr>
<td>a3</td>
<td>23x</td>
<td>shl-long vAA, vBB, vCC</td>
<td>将寄存器对 vBB 中的有符号长整型数左移 vCC 位，结果存入寄存器对 vAA</td>
</tr>
<tr>
<td>a4</td>
<td>23x</td>
<td>shr-long vAA, vBB, vCC</td>
<td>将寄存器对 vBB 中的有符号长整型数右移 vCC 位，结果存入寄存器对 vAA</td>
</tr>
<tr>
<td>a5</td>
<td>23x</td>
<td>ushr-long vAA, vBB, vCC</td>
<td>将寄存器对 vBB 中的无符号长整型数右移 vCC 位，结果存入寄存器对 vAA</td>
</tr>
<tr>
<td>a6</td>
<td>23x</td>
<td>add-float vAA, vBB, vCC</td>
<td>将寄存器 vBB 中的单精度浮点数加上寄存器 vCC 中的单精度浮点数，结果存入寄存器 vAA</td>
</tr>
<tr>
<td>a7</td>
<td>23x</td>
<td>sub-float vAA, vBB, vCC</td>
<td>将寄存器 vBB 中的单精度浮点数减去寄存器 vCC 中的单精度浮点数，结果存入寄存器 vAA</td>
</tr>
<tr>
<td>a8</td>
<td>23x</td>
<td>mul-float vAA, vBB, vCC</td>
<td>将寄存器 vBB 中的单精度浮点数乘以寄存器 vCC 中的单精度浮点数，结果存入寄存器 vAA</td>
</tr>
<tr>
<td>a9</td>
<td>23x</td>
<td>div-float vAA, vBB, vCC</td>
<td>将寄存器 vBB 中的单精度浮点数除以寄存器 vCC 中的单精度浮点数，结果存入寄存器 vAA</td>
</tr>
<tr>
<td>aa</td>
<td>23x</td>
<td>rem-float vAA, vBB, vCC</td>
<td>将寄存器 vBB 中的单精度浮点数和寄存器 vCC 中的单精度浮点数进行模运算，结果存入寄存器 vAA</td>
</tr>
<tr>
<td>ab</td>
<td>23x</td>
<td>add-double vAA, vBB, vCC</td>
<td>将寄存器对 vBB 中的双精度浮点数加上寄存器对 vCC 中的双精度浮点数，结果存入寄存器对 vAA</td>
</tr>
<tr>
<td>ac</td>
<td>23x</td>
<td>sub-double vAA, vBB, vCC</td>
<td>将寄存器对 vBB 中的双精度浮点数减去寄存器对 vCC 中的双精度浮点数，结果存入寄存器对 vAA</td>
</tr>
<tr>
<td>ad</td>
<td>23x</td>
<td>mul-double vAA, vBB, vCC</td>
<td>将寄存器对 vBB 中的双精度浮点数乘以寄存器对 vCC 中的双精度浮点数，结果存入寄存器对 vAA</td>
</tr>
<tr>
<td>ae</td>
<td>23x</td>
<td>div-double vAA, vBB, vCC</td>
<td>将寄存器对 vBB 中的双精度浮点数除以寄存器对 vCC 中的双精度浮点数，结果存入寄存器对 vAA</td>
</tr>
<tr>
<td>af</td>
<td>23x</td>
<td>rem-double vAA, vBB, vCC</td>
<td>将寄存器对 vBB 中的双精度浮点数和寄存器对 vCC 中的双精度浮点数进行模运算，结果存入寄存器对 vAA</td>
</tr>
<tr>
<td>b0</td>
<td>12x</td>
<td>add-int&#x2F;2addr vA, vB</td>
<td>将寄存器 vA 中的整型数加上寄存器 vB 中的整型数，结果存入寄存器 vA</td>
</tr>
<tr>
<td>b1</td>
<td>12x</td>
<td>sub-int&#x2F;2addr vA, vB</td>
<td>将寄存器 vA 中的整型数减去寄存器 vB 中的整型数，结果存入寄存器 vA</td>
</tr>
<tr>
<td>b2</td>
<td>12x</td>
<td>mul-int&#x2F;2addr vA, vB</td>
<td>将寄存器 vA 中的整型数乘以寄存器 vB 中的整型数，结果存入寄存器 vA</td>
</tr>
<tr>
<td>b3</td>
<td>12x</td>
<td>div-int&#x2F;2addr vA, vB</td>
<td>将寄存器 vA 中的整型数除以寄存器 vB 中的整型数，结果存入寄存器 vA</td>
</tr>
<tr>
<td>b4</td>
<td>12x</td>
<td>rem-int&#x2F;2addr vA, vB</td>
<td>将寄存器 vA 中的整型数和寄存器 vB 中的整型数进行模运算，结果存入寄存器 vA</td>
</tr>
<tr>
<td>b5</td>
<td>12x</td>
<td>and-int&#x2F;2addr vA, vB</td>
<td>将寄存器 vA 中的整型数和寄存器 vB 中的整型数进行与运算，结果存入寄存器 vA</td>
</tr>
<tr>
<td>b6</td>
<td>12x</td>
<td>or-int&#x2F;2addr vA, vB</td>
<td>将寄存器 vA 中的整型数和寄存器 vB 中的整型数进行或运算，结果存入寄存器 vA</td>
</tr>
<tr>
<td>b7</td>
<td>12x</td>
<td>xor-int&#x2F;2addr vA, vB</td>
<td>将寄存器 vA 中的整型数和寄存器 vB 中的整型数进行异或运算，结果存入寄存器 vA</td>
</tr>
<tr>
<td>b8</td>
<td>12x</td>
<td>shl-int&#x2F;2addr vA, vB</td>
<td>将寄存器 vA 中的有符号数左移 vB 位，结果存入寄存器 vA</td>
</tr>
<tr>
<td>b9</td>
<td>12x</td>
<td>shr-int&#x2F;2addr vA, vB</td>
<td>将寄存器 vA 中的有符号数右移 vB 位，结果存入寄存器 vA</td>
</tr>
<tr>
<td>ba</td>
<td>12x</td>
<td>ushr-int&#x2F;2addr vA, vB</td>
<td>将寄存器 vA 中的无符号数左移 vB 位，结果存入寄存器 vA</td>
</tr>
<tr>
<td>bb</td>
<td>12x</td>
<td>add-long&#x2F;2addr vA, vB</td>
<td>将寄存器对 vA 中的长整型数加上寄存器对 vB 中的长整型数，结果存入寄存器对 vA</td>
</tr>
<tr>
<td>bc</td>
<td>12x</td>
<td>sub-long&#x2F;2addr vA, vB</td>
<td>将寄存器对 vA 中的长整型数减去寄存器对 vB 中的长整型数，结果存入寄存器对 vA</td>
</tr>
<tr>
<td>bd</td>
<td>12x</td>
<td>mul-long&#x2F;2addr vA, vB</td>
<td>将寄存器对 vA 中的长整型数乘以寄存器对 vB 中的长整型数，结果存入寄存器对 vA</td>
</tr>
<tr>
<td>be</td>
<td>12x</td>
<td>div-long&#x2F;2addr vA, vB</td>
<td>将寄存器对 vA 中的长整型数除以寄存器对 vB 中的长整型数，结果存入寄存器对 vA</td>
</tr>
<tr>
<td>bf</td>
<td>12x</td>
<td>rem-long&#x2F;2addr vA, vB</td>
<td>将寄存器对 vA 中的长整型数和寄存器对 vB 中的长整型数进行模运算，结果存入寄存器对 vA</td>
</tr>
<tr>
<td>c0</td>
<td>12x</td>
<td>and-long&#x2F;2addr vA, vB</td>
<td>将寄存器对 vA 中的长整型数和寄存器对 vB 中的长整型数进行与运算，结果存入寄存器对 vA</td>
</tr>
<tr>
<td>c1</td>
<td>12x</td>
<td>or-long&#x2F;2addr vA, vB</td>
<td>将寄存器对 vA 中的长整型数和寄存器对 vB 中的长整型数进行或运算，结果存入寄存器对 vA</td>
</tr>
<tr>
<td>c2</td>
<td>12x</td>
<td>xor-long&#x2F;2addr vA, vB</td>
<td>将寄存器对 vA 中的长整型数和寄存器对 vB 中的长整型数进异或运算，结果存入寄存器对 vA</td>
</tr>
<tr>
<td>c3</td>
<td>12x</td>
<td>shl-long&#x2F;2addr vA, vB</td>
<td>将寄存器对 vA 中的有符号长整型数左移 vB 位，结果存入寄存器对 vA</td>
</tr>
<tr>
<td>c4</td>
<td>12x</td>
<td>shr-long&#x2F;2addr vA, vB</td>
<td>将寄存器对 vA 中的有符号长整型数右移 vB 位，结果存入寄存器对 vA</td>
</tr>
<tr>
<td>c5</td>
<td>12x</td>
<td>ushr-long&#x2F;2addr vA, vB</td>
<td>将寄存器对 vA 中的无符号长整型数左移 vB 位，结果存入寄存器对 vA</td>
</tr>
<tr>
<td>c6</td>
<td>12x</td>
<td>add-float&#x2F;2addr vA, vB</td>
<td>将寄存器 vA 中的单精度浮点数加上寄存器 vB 中的单精度浮点数，结果存入寄存器 vA</td>
</tr>
<tr>
<td>c7</td>
<td>12x</td>
<td>sub-float&#x2F;2addr vA, vB</td>
<td>将寄存器 vA 中的单精度浮点数减去寄存器 vB 中的单精度浮点数，结果存入寄存器 vA</td>
</tr>
<tr>
<td>c8</td>
<td>12x</td>
<td>mul-float&#x2F;2addr vA, vB</td>
<td>将寄存器 vA 中的单精度浮点数乘以寄存器 vB 中的单精度浮点数，结果存入寄存器 vA</td>
</tr>
<tr>
<td>c9</td>
<td>12x</td>
<td>div-float&#x2F;2addr vA, vB</td>
<td>将寄存器 vA 中的单精度浮点数除以寄存器 vB 中的单精度浮点数，结果存入寄存器 vA</td>
</tr>
<tr>
<td>ca</td>
<td>12x</td>
<td>rem-float&#x2F;2addr vA, vB</td>
<td>将寄存器 vA 中的单精度浮点数和寄存器 vB 中的单精度浮点数进行模运算，结果存入寄存器 vA</td>
</tr>
<tr>
<td>cb</td>
<td>12x</td>
<td>add-double&#x2F;2addr vA, vB</td>
<td>将寄存器对 vA 中的双精度浮点数加上寄存器对 vB 中的双精度浮点数，结果存入寄存器对 vA</td>
</tr>
<tr>
<td>cc</td>
<td>12x</td>
<td>sub-double&#x2F;2addr vA, vB</td>
<td>将寄存器对 vA 中的双精度浮点数减去寄存器对 vB 中的双精度浮点数，结果存入寄存器对 vA</td>
</tr>
<tr>
<td>cd</td>
<td>12x</td>
<td>mul-double&#x2F;2addr vA, vB</td>
<td>将寄存器对 vA 中的双精度浮点数乘以寄存器对 vB 中的双精度浮点数，结果存入寄存器对 vA</td>
</tr>
<tr>
<td>ce</td>
<td>12x</td>
<td>div-double&#x2F;2addr vA, vB</td>
<td>将寄存器对 vA 中的双精度浮点数除以寄存器对 vB 中的双精度浮点数，结果存入寄存器对 vA</td>
</tr>
<tr>
<td>cf</td>
<td>12x</td>
<td>rem-double&#x2F;2addr vA, vB</td>
<td>将寄存器对 vA 中的双精度浮点数和寄存器对 vB 中的双精度浮点数进行模运算，结果存入寄存器对 vA</td>
</tr>
<tr>
<td>d0</td>
<td>22s</td>
<td>add-int&#x2F;lit16 vA, vB, #+CCCC</td>
<td>将寄存器 vB 中的整型数和 16 位字面量 CCCC 相加，结果存入寄存器 vA</td>
</tr>
<tr>
<td>d1</td>
<td>22s</td>
<td>rsub-int vA, vB, #+CCCC</td>
<td>将寄存器 vB 中的整型数和 16 位字面量 CCCC 相减，结果存入寄存器 vA</td>
</tr>
<tr>
<td>d2</td>
<td>22s</td>
<td>mul-int&#x2F;lit16 vA, vB, #+CCCC</td>
<td>将寄存器 vB 中的整型数和 16 位字面量 CCCC 相乘，结果存入寄存器 vA</td>
</tr>
<tr>
<td>d3</td>
<td>22s</td>
<td>div-int&#x2F;lit16 vA, vB, #+CCCC</td>
<td>将寄存器 vB 中的整型数和 16 位字面量 CCCC 相除，结果存入寄存器 vA</td>
</tr>
<tr>
<td>d4</td>
<td>22s</td>
<td>rem-int&#x2F;lit16 vA, vB, #+CCCC</td>
<td>将寄存器 vB 中的整型数和 16 位字面量 CCCC 进行模运算，结果存入寄存器 vA</td>
</tr>
<tr>
<td>d5</td>
<td>22s</td>
<td>and-int&#x2F;lit16 vA, vB, #+CCCC</td>
<td>将寄存器 vB 中的整型数和 16 位字面量 CCCC 进行与运算，结果存入寄存器 vA</td>
</tr>
<tr>
<td>d6</td>
<td>22s</td>
<td>or-int&#x2F;lit16 vA, vB, #+CCCC</td>
<td>将寄存器 vB 中的整型数和 16 位字面量 CCCC 进行或运算，结果存入寄存器 vA</td>
</tr>
<tr>
<td>d7</td>
<td>22s</td>
<td>xor-int&#x2F;lit16 vA, vB, #+CCCC</td>
<td>将寄存器 vB 中的整型数和 16 位字面量 CCCC 进行异或运算，结果存入寄存器 vA</td>
</tr>
<tr>
<td>d8</td>
<td>22b</td>
<td>add-int&#x2F;lit8 vAA, vBB, #+CC</td>
<td>将寄存器 vBB 中的整型数和 8 位字面量 CC 相加，结果存入寄存器 vAA</td>
</tr>
<tr>
<td>d9</td>
<td>22b</td>
<td>rsub-int&#x2F;lit8 vAA, vBB, #+CC</td>
<td>将寄存器 vBB 中的整型数和 8 位字面量 CC 相减，结果存入寄存器 vAA</td>
</tr>
<tr>
<td>da</td>
<td>22b</td>
<td>mul-int&#x2F;lit8 vAA, vBB, #+CC</td>
<td>将寄存器 vBB 中的整型数和 8 位字面量 CC 相乘，结果存入寄存器 vAA</td>
</tr>
<tr>
<td>db</td>
<td>22b</td>
<td>div-int&#x2F;lit8 vAA, vBB, #+CC</td>
<td>将寄存器 vBB 中的整型数和 8 位字面量 CC 相除，结果存入寄存器 vAA</td>
</tr>
<tr>
<td>dc</td>
<td>22b</td>
<td>rem-int&#x2F;lit8 vAA, vBB, #+CC</td>
<td>将寄存器 vBB 中的整型数和 8 位字面量 CC 进行模运算，结果存入寄存器 vAA</td>
</tr>
<tr>
<td>dd</td>
<td>22b</td>
<td>and-int&#x2F;lit8 vAA, vBB, #+CC</td>
<td>将寄存器 vBB 中的整型数和 8 位字面量 CC 进行与运算，结果存入寄存器 vAA</td>
</tr>
<tr>
<td>de</td>
<td>22b</td>
<td>or-int&#x2F;lit8 vAA, vBB, #+CC</td>
<td>将寄存器 vBB 中的整型数和 8 位字面量 CC 进行或运算，结果存入寄存器 vAA</td>
</tr>
<tr>
<td>df</td>
<td>22b</td>
<td>xor-int&#x2F;lit8 vAA, vBB, #+CC</td>
<td>将寄存器 vBB 中的整型数和 8 位字面量 CC 进行异或运算，结果存入寄存器 vAA</td>
</tr>
<tr>
<td>e0</td>
<td>22b</td>
<td>shl-int&#x2F;lit8 vAA, vBB, #+CC</td>
<td>将寄存器 vBB 中的有符号数左移 CC 位，将结果存入寄存器 vAA</td>
</tr>
<tr>
<td>e1</td>
<td>22b</td>
<td>shr-int&#x2F;lit8 vAA, vBB, #+CC</td>
<td>将寄存器 vBB 中的有符号数右移 CC 位，将结果存入寄存器 vAA</td>
</tr>
<tr>
<td>e2</td>
<td>22b</td>
<td>ushr-int&#x2F;lit8 vAA, vBB, #+CC</td>
<td>将寄存器 vBB 中的无符号数右移 CC 位，将结果存入寄存器 vAA</td>
</tr>
<tr>
<td>e3</td>
<td>10x</td>
<td>unused</td>
<td></td>
</tr>
<tr>
<td>e4</td>
<td>10x</td>
<td>unused</td>
<td></td>
</tr>
<tr>
<td>e5</td>
<td>10x</td>
<td>unused</td>
<td></td>
</tr>
<tr>
<td>e6</td>
<td>10x</td>
<td>unused</td>
<td></td>
</tr>
<tr>
<td>e7</td>
<td>10x</td>
<td>unused</td>
<td></td>
</tr>
<tr>
<td>e8</td>
<td>10x</td>
<td>unused</td>
<td></td>
</tr>
<tr>
<td>e9</td>
<td>10x</td>
<td>unused</td>
<td></td>
</tr>
<tr>
<td>ea</td>
<td>10x</td>
<td>unused</td>
<td></td>
</tr>
<tr>
<td>eb</td>
<td>10x</td>
<td>unused</td>
<td></td>
</tr>
<tr>
<td>ec</td>
<td>10x</td>
<td>unused</td>
<td></td>
</tr>
<tr>
<td>ed</td>
<td>10x</td>
<td>unused</td>
<td></td>
</tr>
<tr>
<td>ee</td>
<td>10x</td>
<td>unused</td>
<td></td>
</tr>
<tr>
<td>ef</td>
<td>10x</td>
<td>unused</td>
<td></td>
</tr>
<tr>
<td>f0</td>
<td>10x</td>
<td>unused</td>
<td></td>
</tr>
<tr>
<td>f1</td>
<td>10x</td>
<td>unused</td>
<td></td>
</tr>
<tr>
<td>f2</td>
<td>10x</td>
<td>unused</td>
<td></td>
</tr>
<tr>
<td>f3</td>
<td>10x</td>
<td>unused</td>
<td></td>
</tr>
<tr>
<td>f4</td>
<td>10x</td>
<td>unused</td>
<td></td>
</tr>
<tr>
<td>f5</td>
<td>10x</td>
<td>unused</td>
<td></td>
</tr>
<tr>
<td>f6</td>
<td>10x</td>
<td>unused</td>
<td></td>
</tr>
<tr>
<td>f7</td>
<td>10x</td>
<td>unused</td>
<td></td>
</tr>
<tr>
<td>f8</td>
<td>10x</td>
<td>unused</td>
<td></td>
</tr>
<tr>
<td>f9</td>
<td>10x</td>
<td>unused</td>
<td></td>
</tr>
<tr>
<td>fa</td>
<td>45cc</td>
<td>invoke-polymorphic {vC, vD, vE, vF, vG}, meth@BBBB, proto@HHHH</td>
<td>调用指定的签名多态方法,存在于 038 和更高版本的 Dex 文件中</td>
</tr>
<tr>
<td>fb</td>
<td>4rcc</td>
<td>invoke-polymorphic&#x2F;range {vCCCC .. vNNNN}, meth@BBBB, proto@HHHH</td>
<td>调用指定的方法句柄,存在于版本 038 及更高版本的 Dex 文件中</td>
</tr>
<tr>
<td>fc</td>
<td>35c</td>
<td>invoke-custom {vC, vD, vE, vF, vG}, call_site@BBBB</td>
<td>解析并调用指定的调用点,存在于版本 038 及更高版本的 Dex 文件中</td>
</tr>
<tr>
<td>fd</td>
<td>3rc</td>
<td>invoke-custom&#x2F;range {vCCCC .. vNNNN}, call_site@BBBB</td>
<td>解析并调用一个调用点,存在于版本 038 及更高版本的 Dex 文件中</td>
</tr>
<tr>
<td>fe</td>
<td>21c</td>
<td>const-method-handle vAA, method_handle@BBBB</td>
<td>将通过特定索引指定的方法句柄的引用移到指定的寄存器中,存在于版本 039 及更高版本的 Dex 文件中</td>
</tr>
<tr>
<td>ff</td>
<td>21c</td>
<td>const-method-type vAA, proto@BBBB</td>
<td>将通过特定索引指定的方法原型的引用移到指定的寄存器中。存在于版本 039 及更高版本的 Dex 文件中</td>
</tr>
</tbody></table>
</details>

<h3 id="Dalvik指令练习"><a href="#Dalvik指令练习" class="headerlink" title="Dalvik指令练习"></a>Dalvik指令练习</h3><h4 id="编写HelloWorld-smali文件"><a href="#编写HelloWorld-smali文件" class="headerlink" title="编写HelloWorld.smali文件"></a>编写HelloWorld.smali文件</h4><div class="highlight-wrap" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 定义类名</span></span><br><span class="line">.class public LHelloword;</span><br><span class="line"><span class="comment"># 定义父类</span></span><br><span class="line">.super Ljava/lang/object;</span><br><span class="line"><span class="comment"># 声明静态main方法</span></span><br><span class="line">.method public static main([Ljava/lang/String;)V</span><br><span class="line">	<span class="comment"># 程序使用v0,v1,v2和一个参数寄存器共四个</span></span><br><span class="line">	.registers 4</span><br><span class="line">	<span class="comment"># 代码起始指令</span></span><br><span class="line">	.prologue</span><br><span class="line">	<span class="comment"># 空指令</span></span><br><span class="line">	nop</span><br><span class="line">	nop</span><br><span class="line">	nop</span><br><span class="line">	nop</span><br><span class="line">	<span class="comment"># 数据定义指令</span></span><br><span class="line">	const/16 v0, 0x8</span><br><span class="line">	const/4 v1, 0x5</span><br><span class="line">	const/v v2, 0x3</span><br><span class="line">	<span class="comment"># 数据操作指令</span></span><br><span class="line">	move v1, v2</span><br><span class="line">	<span class="comment"># 数据操作指令</span></span><br><span class="line">	new-array v0, v0, [I</span><br><span class="line">	array-length v1, v0</span><br><span class="line">	<span class="comment"># 实例操作指令</span></span><br><span class="line">	new-instance v1, Ljava/lang/StringBuilder;</span><br><span class="line">	<span class="comment"># 方法调用指令</span></span><br><span class="line">	invoke-direct &#123;v1&#125;, Ljava/lang/StringBuilder;-&gt;&lt;init&gt;()V</span><br><span class="line">	<span class="comment"># 跳转指令</span></span><br><span class="line">	if-nez v0, :cond_0</span><br><span class="line">	goto :goto_0</span><br><span class="line">	:cond_0</span><br><span class="line">	<span class="comment"># 数据转换指令</span></span><br><span class="line">	int-to-float v2, v2</span><br><span class="line">	<span class="comment"># 数据运算指令</span></span><br><span class="line">	add-float v2, v2, v2</span><br><span class="line">	<span class="comment"># 比较指令</span></span><br><span class="line">	cmpl-float v0, v2, v2</span><br><span class="line">	<span class="comment"># 字段操作指令</span></span><br><span class="line">	sget-object v0, Ljava/lang/System;-&gt;out:Ljava/io/PrintStream;</span><br><span class="line">	<span class="comment"># 构造字符串</span></span><br><span class="line">	const-string v1, <span class="string">&quot;Hello World&quot;</span></span><br><span class="line">	<span class="comment"># 方法调用</span></span><br><span class="line">	invoke-virtual &#123;v0, v1&#125;, Ljava/io/PrintStream;-&gt;println(Ljava/lang/String;)V</span><br><span class="line">	<span class="comment"># 返回指令</span></span><br><span class="line">	:goto_0</span><br><span class="line">	</span><br><span class="line">	return-void</span><br><span class="line">.end method</span><br></pre></td></tr></table></figure></div>

<h4 id="编译smali文件"><a href="#编译smali文件" class="headerlink" title="编译smali文件"></a>编译smali文件</h4><p>使用smali工具来编译smail文件，可以到这里在线下载<a href="https://bitbucket.org/JesusFreke/smali/downloads/">smali</a>，同时我也下到了本地，<a href="smali-2.1.1.jar">点击下载</a><br>执行如下命令编译smali文件</p>
<div class="highlight-wrap" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">java -jar smali-2.1.1.jar -o HelloWorld.dex HelloWorld.smali</span><br></pre></td></tr></table></figure></div>
<br>
在当前文件夹下生成[HellowWorld.dex](HelloWorld.dex)文件
**注意：**smali-2.1.1.jar后面的版本执行会出现如下错误：
<div class="highlight-wrap" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">Exception <span class="keyword">in</span> thread <span class="string">&quot;main&quot;</span> com.beust.jcommander.MissingCommandException: Expected a <span class="built_in">command</span>, got -o</span><br><span class="line">        at com.beust.jcommander.JCommander.parseValues(JCommander.java:725)</span><br><span class="line">        at com.beust.jcommander.JCommander.parse(JCommander.java:304)</span><br><span class="line">        at com.beust.jcommander.JCommander.parse(JCommander.java:287)</span><br><span class="line">        at org.jf.smali.Main.main(Main.java:88) </span><br></pre></td></tr></table></figure></div>
<br>
换smali-2.1.1.jar就可以成功生成dex,新的smail编译使用方法有知道的可以留意告知。

<h4 id="测试运行DEX文件"><a href="#测试运行DEX文件" class="headerlink" title="测试运行DEX文件"></a>测试运行DEX文件</h4><p>在Android设备下执行如下命令运行DEX文件</p>
<div class="highlight-wrap" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">adb push HelloWorld.dex /sdcard/</span><br><span class="line">adb shell dalvikvm -<span class="built_in">cp</span> /sdcard/HelloWorld.dex HelloWorld</span><br></pre></td></tr></table></figure></div>
<br>
执行上面命令后如果成功，最后会打印"HelloWorld"。









]]></content>
      <categories>
        <category>Android</category>
        <category>逆向</category>
        <category>《Android软件安全权威指南》实践笔记</category>
      </categories>
      <tags>
        <tag>Android逆向</tag>
      </tags>
  </entry>
  <entry>
    <title>工具网站合集</title>
    <url>/2022/10/16/tool-website-collection/</url>
    <content><![CDATA[<h2 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h2><ul>
<li>生成图片<ul>
<li>生成好看的渐变背景图: <a href="https://coolbackgrounds.io/">Cool Backgrounds</a></li>
<li>生成类似 mac 风格的代码图片: <a href="https://carbon.now.sh/">carbon </a></li>
<li>生成随机图片<a href="https://unsplash.com/developers">Unsplash Source</a></li>
<li>在线 logo 随机生成工具<a href="http://emblemmatic.org/markmaker/#/">MarkMaker</a></li>
</ul>
</li>
<li>阿里巴巴矢量图标库:<a href="http://www.iconfont.cn/plus">iconfont</a></li>
<li>壁纸: <a href="https://www.desktoppr.co/wallpapers">desktoppr</a></li>
<li>Material icons图标:<a href="https://material.io/tools/icons/?style=baseline">Material icons</a></li>
<li>批量编辑图片的所有工具。包括压缩图片，剪裁图片，图片加水印，转化至jpg图片等等:<a href="https://www.iloveimg.com/zh-cn">Iloveimg</a></li>
<li>任意GIF添加字幕<a href="https://www.pkgif.net/">pkgif</a></li>
<li>一键下载当前网页的所有图片<a href="https://appscyborg.com/image-cyborg/">ImageCyborg</a></li>
<li>免费正版图片资源<ul>
<li><a href="https://unsplash.com/">https://unsplash.com/</a></li>
<li><a href="https://pixabay.com/zh/">https://pixabay.com/zh/</a></li>
<li><a href="http://www.piqsels.com/zh">http://www.piqsels.com/zh</a></li>
</ul>
</li>
<li>一键背景消除：<a href="https://www.remove.bg/zh">https://www.remove.bg/zh</a></li>
<li>证件照换底色：<a href="https://www.bgconverter.com/">https://www.bgconverter.com/</a></li>
<li>将照片变成艺术照：<a href="https://deepart.io/">https://deepart.io/</a></li>
<li>图片压缩：<ul>
<li><a href="https://tinypng.com/">https://tinypng.com/</a></li>
<li><a href="http://zhitu.isux.us/">智图</a></li>
<li><a href="https://tinypng.com/">Tinypng</a></li>
<li>SVG图形压缩优化:<a href="https://jakearchibald.github.io/svgomg/">SVGOMG</a></li>
</ul>
</li>
<li>电影截图：<a href="https://film-grab.com/">https://film-grab.com/</a></li>
<li>样机图片大全：<a href="https://mockupplanet.com/">https://mockupplanet.com/</a></li>
</ul>
<h2 id="视频"><a href="#视频" class="headerlink" title="视频"></a>视频</h2><ul>
<li>快手、抖音、秒拍视频解析：<a href="https://www.parsevideo.com/">https://www.parsevideo.com/</a></li>
</ul>
<h2 id="书籍"><a href="#书籍" class="headerlink" title="书籍"></a>书籍</h2><ul>
<li>鸠摩搜书：<a href="https://www.jiumodiary.com/">https://www.jiumodiary.com/</a></li>
<li>免费古籍图书：<a href="https://new.shuge.org/">https://new.shuge.org/</a></li>
</ul>
<h2 id="纪录片"><a href="#纪录片" class="headerlink" title="纪录片"></a>纪录片</h2><ul>
<li>纪录片天地：<a href="http://www.jlpcn.net/">http://www.jlpcn.net/</a></li>
<li>纪录片之家：<a href="http://www.jlpdq.com/">http://www.jlpdq.com/</a></li>
</ul>
<h2 id="网络-amp-安全"><a href="#网络-amp-安全" class="headerlink" title="网络&amp;安全"></a>网络&amp;安全</h2><ul>
<li>查看IP伪装信息：<a href="https://whoer.net/zh">https://whoer.net/zh</a></li>
<li>查看密码泄漏：<a href="https://haveibeenpwned.com/">https://haveibeenpwned.com/</a></li>
<li>网站公用账号：<a href="http://bugmenot.com/">http://bugmenot.com/</a></li>
<li>检查网站状态：<a href="https://zijian.aliyun.com/">https://zijian.aliyun.com/</a></li>
<li>免费uptime监控：<a href="https://uptimerobot.com/">https://uptimerobot.com/</a></li>
<li>whois查询：<a href="https://whois.aliyun.com/">https://whois.aliyun.com</a></li>
<li>IP ping、路由查询：<a href="https://tools.ipip.net/newping.php">https://tools.ipip.net/newping.php</a></li>
<li>网页速度测试：<a href="https://developers.google.com/speed/pagespeed/insights/">https://developers.google.com/speed/pagespeed/insights/</a></li>
<li>域名低价查询：<a href="https://tld-list.com/">https://tld-list.com</a></li>
<li>DNS<ul>
<li>ip域名查询：<a href="https://site.ip138.com/">https://site.ip138.com</a></li>
<li><a href="https://securitytrails.com/">https://securitytrails.com/</a></li>
</ul>
</li>
</ul>
<h2 id="AI"><a href="#AI" class="headerlink" title="AI"></a>AI</h2><ul>
<li>AI论文生成工具：<a href="https://essay.1ts.fun/">https://essay.1ts.fun</a></li>
<li>AI写作机器人：<a href="https://www.giiso.com/#/">https://www.giiso.com/#/</a></li>
<li>AI自动上色：<a href="https://petalica-paint.pixiv.dev/index_zh.html">https://petalica-paint.pixiv.dev/index_zh.html</a></li>
<li>AI写对联：<a href="http://duilian.msra.cn/app/couplet.aspx">http://duilian.msra.cn/app/couplet.aspx</a></li>
<li>AI生成照片：<a href="http://www.seeprettyface.com/index.html">http://www.seeprettyface.com/index.html</a></li>
<li>AI做PPT：<a href="https://www.beautiful.ai/">https://www.beautiful.ai/</a></li>
</ul>
<h2 id="编程"><a href="#编程" class="headerlink" title="编程"></a>编程</h2><ul>
<li>以动画的形式让你学习 git: <a href="https://learngitbranching.js.org/?locale=zh_CN">Learn Git Branching</a></li>
<li>代码格式美化：<a href="https://carbon.now.sh/">https://carbon.now.sh/</a></li>
<li>编程语言性能对比：<a href="https://benchmarksgame-team.pages.debian.net/benchmarksgame/">https://benchmarksgame-team.pages.debian.net/benchmarksgame/</a></li>
<li>代码分享: [Ubuntu pastebin] (<a href="https://paste.ubuntu.com/">https://paste.ubuntu.com/</a>)</li>
<li>在线代码编辑:<ul>
<li><a href="https://codepen.io/">Codepen</a></li>
<li><a href="http://jsbin.com/">Jsbin</a></li>
<li>在线写React,自动编译,有代码提示: <a href="https://codesandbox.io/">CodeSandbox</a></li>
</ul>
</li>
<li>正则可视化: <a href="https://regexper.com/">Regexper</a></li>
<li>正则表达式测试: <a href="https://regex101.com/">Regex101</a></li>
<li>数据结构，算法可视化: <a href="https://visualgo.net/">Visualgo</a></li>
<li>测试网站速度，优化性能: <a href="https://pagespeed.web.dev/">PageSpeed Insights</a></li>
<li>生成类似代码注释里那种佛祖的代码: <a href="http://asciiflow.com/">Asciiflow</a></li>
<li>生成 nginx 配置: <a href="https://www.digitalocean.com/community/tools/nginx?global.app.lang=zhCN">NGINXConfig</a></li>
<li>开发变量命名神器: <a href="https://unbug.github.io/codelf/">codeif</a></li>
<li>常用速查表，快速查询各类框架和库的常用方法，很实用：<a href="https://devhints.io/">devhints</a></li>
<li>快速查询各类框架和周边库的中文文档: <a href="https://docschina.org/">印记中文</a></li>
<li>搜索网站是否有不安全的头部 header 设置，并会评分: <a href="https://securityheaders.com/">Security Headers</a></li>
<li>各种编程语言 API 文档<a href="https://devdocs.io/">devdocs</a></li>
</ul>
<h2 id="在线软件"><a href="#在线软件" class="headerlink" title="在线软件"></a>在线软件</h2><ul>
<li>简历<ul>
<li>简历模板: <a href="https://www.hloom.com/resume-examples/">resume-examples</a></li>
<li>生成简历: <a href="https://enhancv.com/">Enhancv</a></li>
</ul>
</li>
<li>在线绘画：<a href="https://www.autodraw.com/">https://www.autodraw.com/</a></li>
<li>在线流程图：<a href="https://app.diagrams.net/">https://app.diagrams.net/</a></li>
<li>在线画流程图，思维导图、UI原型图等等<ul>
<li><a href="https://www.processon.com/">ProcessOn</a></li>
<li><a href="https://www.draw.io/">draw.io</a></li>
</ul>
</li>
<li>在线PS：<a href="https://www.photopea.com/">https://www.photopea.com/</a></li>
<li>在线文件转换，支持 200 多种文件格式转换<a href="https://www.alltoall.net/">alltoall</a></li>
<li>能够在线使用ps，ai，office，xmind，火狐浏览器等多个应用的网站<a href="https://uzer.me/">uzer</a></li>
<li>在线图表制作工具<a href="https://infogram.com/">infogram</a></li>
<li>极简大纲笔记，一键生成思维导图:<a href="http://mubu.com/home">幕布</a></li>
<li>在线制作 PPT:<ul>
<li><a href="https://ppt.baomitu.com/">声享</a></li>
<li>人工智能 ppt 模板创建:<a href="https://about.beautiful.ai/">Beautiful.Ai</a></li>
<li>ppt 模板<a href="http://www.koppt.cn/index">KOPPT</a></li>
</ul>
</li>
<li>在线生成二维码:<a href="https://cli.im/">草料二维码</a></li>
<li>PDF压缩，PDF转PPT，Word，Excel等等都可以直接通过这个页面实现:<a href="https://smallpdf.com/">Smallpdf</a></li>
</ul>
<h2 id="设计"><a href="#设计" class="headerlink" title="设计"></a>设计</h2><ul>
<li>配色：<ul>
<li><a href="https://colorhunt.co/">https://colorhunt.co/</a></li>
<li><a href="https://color.adobe.com/zh/create/color-wheel">https://color.adobe.com/zh/create/color-wheel</a></li>
<li><a href="https://www.webdesignrankings.com/resources/lolcolors/">https://www.webdesignrankings.com/resources/lolcolors/</a></li>
</ul>
</li>
</ul>
<h2 id="合集类工具网站"><a href="#合集类工具网站" class="headerlink" title="合集类工具网站"></a>合集类工具网站</h2><ul>
<li><a href="https://shadiao.pro/">https://shadiao.pro/</a></li>
</ul>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><ul>
<li>免费微信消息推送(Server酱)：<a href="http://sc.ftqq.com/">http://sc.ftqq.com/</a></li>
<li>中国老海报（国内被墙）：<a href="https://chineseposters.net/">https://chineseposters.net/</a></li>
<li>查看软件替代品：<a href="https://alternativeto.net/">https://alternativeto.net/</a></li>
<li>渣男说话艺术：<a href="https://lovelive.tools/">https://lovelive.tools/</a></li>
</ul>
]]></content>
      <categories>
        <category>工具箱</category>
        <category>工具网站</category>
      </categories>
      <tags>
        <tag>工具网站</tag>
      </tags>
  </entry>
  <entry>
    <title>Android源码查看</title>
    <url>/2022/10/21/view_android_source_code/</url>
    <content><![CDATA[<p>查看Android源码的方式分为在线网页查看和下载到本地查看，本文对这些方式做记录，依据使用场景来遍历分析查看Android源码内容</p>
<h2 id="Windows下载查看Android源码"><a href="#Windows下载查看Android源码" class="headerlink" title="Windows下载查看Android源码"></a>Windows下载查看Android源码</h2><h3 id="安装工具软件"><a href="#安装工具软件" class="headerlink" title="安装工具软件"></a>安装工具软件</h3><p>其他环境下下载源码使用repo这个工具，Windows里面搞repo有点麻烦，这里直接才有git clone的方式拷贝源码的每个子工程项目。在Windows端下载Android源码需要确认安装以下软件，列出我本地实践的一些软件以及版本,这两个工具软件安装不做记录</p>
<blockquote>
<p><a href="https://git-scm.com/download/win">Git</a>: 2.9.0</p>
<p><a href="https://www.python.org/downloads/">Python</a>：3.9</p>
<p>我下载的android_10_0_0_r47版本，占用磁盘硬盘293G，建议搞一个空盘有300G的空间</p>
</blockquote>
<h3 id="配置下载源码"><a href="#配置下载源码" class="headerlink" title="配置下载源码"></a>配置下载源码</h3><ul>
<li><p>本地新建文件夹结构<br>我在此处建的文件夹结构如下：</p>
<div class="highlight-wrap" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">F:\Android\AOSP\clone_tsinghua</span><br></pre></td></tr></table></figure></div>
</br></li>
<li><p>克隆清华大学开源软件镜像（不用google的避免要翻墙）</p>
<div class="highlight-wrap" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://aosp.tuna.tsinghua.edu.cn/platform/manifest.git</span><br></pre></td></tr></table></figure></div>
</br></li>
<li><p>选择一个下载版本</p>
<div class="highlight-wrap" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> manifest</span><br><span class="line">// 切换到android-10.0.0_r47分支</span><br><span class="line">git checkout -b android-10.0.0_r47 origin/android-10.0.0_r47</span><br></pre></td></tr></table></figure></div>
</br>
可以在manifest目录执行``git branch -a``查看所有的分支情况选择一个需要的版本源码，同意可以在[官网](https://source.android.google.cn/docs/setup/about/build-numbers#source-code-tags-and-builds)找到对应的标记版本
</li>
<li><p>编写python下载脚本<br>文件结构新建python文件：F:\Android\AOSP\clone_tsinghua\downloadAOSP.py, 提供一个可下载：<a href="downloadAOSP.py">downloadAOSP.py</a></p>
<div class="highlight-wrap" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">import xml.dom.minidom</span><br><span class="line">import os</span><br><span class="line">from subprocess import call</span><br><span class="line">// 注意地址中使用的是 <span class="string">&quot;/&quot;</span> 而不是<span class="string">&quot;\&quot;, unbantu 跟Windows 是有区别的</span></span><br><span class="line"><span class="string">// 代码保存位置，硬盘建议大于100G</span></span><br><span class="line"><span class="string">rootdir = &quot;</span>F:/Android/AOSP/android_10_0_0_r47<span class="string">&quot;</span></span><br><span class="line"><span class="string">// git 安装路径，可以使用 where git 命令查看</span></span><br><span class="line"><span class="string">git = &quot;</span>D:/Program Files/Git/bin/git.exe<span class="string">&quot;</span></span><br><span class="line"><span class="string">// 刚刚切换 android-10.0.0_r47 目录下的defaul.xml 文件</span></span><br><span class="line"><span class="string">dom = xml.dom.minidom.parse(&quot;</span>F:/Android/AOSP/clone_tsinghua/manifest/default.xml<span class="string">&quot;)</span></span><br><span class="line"><span class="string">root = dom.documentElement</span></span><br><span class="line"><span class="string">// clone 清华大学镜像库地址</span></span><br><span class="line"><span class="string">prefix = git + &quot;</span> <span class="built_in">clone</span> https://mirrors.tuna.tsinghua.edu.cn/git/AOSP/<span class="string">&quot;</span></span><br><span class="line"><span class="string">suffix = &quot;</span>.git<span class="string">&quot;</span></span><br><span class="line"><span class="string">if not os.path.exists(rootdir):</span></span><br><span class="line"><span class="string">    os.mkdir(rootdir)</span></span><br><span class="line"><span class="string"> </span></span><br><span class="line"><span class="string">for node in root.getElementsByTagName(&quot;</span>project<span class="string">&quot;):</span></span><br><span class="line"><span class="string">    os.chdir(rootdir)</span></span><br><span class="line"><span class="string">    d = node.getAttribute(&quot;</span>path<span class="string">&quot;)</span></span><br><span class="line"><span class="string">    last = d.rfind(&quot;</span>/<span class="string">&quot;)</span></span><br><span class="line"><span class="string">    if last != -1:</span></span><br><span class="line"><span class="string">        d = rootdir + &quot;</span>/<span class="string">&quot; + d[:last]</span></span><br><span class="line"><span class="string">        if not os.path.exists(d):</span></span><br><span class="line"><span class="string">            os.makedirs(d)</span></span><br><span class="line"><span class="string">        os.chdir(d)</span></span><br><span class="line"><span class="string">    cmd = prefix + node.getAttribute(&quot;</span>name<span class="string">&quot;) + suffix</span></span><br><span class="line"><span class="string">    call(cmd)</span></span><br></pre></td></tr></table></figure></div>
</br>
</li>
<li><p>执行下载脚本开始下载<br>双击downloadAOSP.py或者在终端执行<code>python downloadAOSP.py</code>即可开始下载对应的Android源码了。注意脚本里面的路径要换成你的电脑环境的路径</p>
</li>
</ul>
<p>下载完成后建议配合sourceinsight查看源码，可以链接代码。下载下来后占用磁盘将近300G，太大了，还有使用在线网页的方式可以更加轻量的查看源码</p>
<h2 id="网页查看Android源码"><a href="#网页查看Android源码" class="headerlink" title="网页查看Android源码"></a>网页查看Android源码</h2><p>如果不想占用过多的磁盘，并且在线查看源码，推荐几个好用的在线网站。</p>
<h3 id="Google官方源码地址"><a href="#Google官方源码地址" class="headerlink" title="Google官方源码地址"></a>Google官方源码地址</h3><p>如果方便翻墙，可以使用Google官方的源码查看网站：<a href="cs.android.com">cs.android.com</a>,版本信息很全，而且带有修改记录，源码阅读神奇</p>
<h3 id="Android-Ref"><a href="#Android-Ref" class="headerlink" title="Android Ref"></a>Android Ref</h3><p><a href="androidxref.com">Android Ref</a> 国外网站，但是无需翻墙访问，但是只支持到Android9的源码</p>
<h3 id="Android-中文社区"><a href="#Android-中文社区" class="headerlink" title="Android 中文社区"></a>Android 中文社区</h3><p><a href="www.androidos.net.cn/sourcecode">Android 中文社区</a>是国内网站，支持到Android10</p>
]]></content>
      <categories>
        <category>Android</category>
        <category>源码</category>
      </categories>
      <tags>
        <tag>Android源码</tag>
      </tags>
  </entry>
  <entry>
    <title>vultr+v2ray科学上网[翻墙]配置2022</title>
    <url>/2022/10/07/vultr&amp;v2ray_scientific_internet_access/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ul>
<li><p>本博客适合小白一步步操作在自己的vps上搭建科学上网配置，并且对vps 服务器的要求不是很高，自己科学上网使用即可的用户服用。</p>
</li>
<li><p>vps服务器的选择国内国外都有很多，我们要做的操作首选国外的服务器（你懂的）开始博主想要弄oracle和Google的永久免费服务器，但是发现这些要一些国外的信用卡注册，属实太麻烦，然后发现比较稳定的有<a href="https://bandwagonhost.com/">搬瓦工</a>的服务器，奈何贫穷限制了我的选择，博客今日时间点最便宜的需要49.99美元(354.22人名币)，最后各种倒腾得支持国内支付的，选择了<a href="https://www.vultr.com/?ref=9246988-8H">vultr</a> 3.5美元&#x2F;月的, <font color=red>注意必须从我这个分享链接注册使用可以的到充值送100美元的福利</p>
</font></li>
</ul>
<h2 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h2><blockquote>
<p> <strong>vps：</strong><a href="https://www.vultr.com/?ref=9246988-8H">Vultr</a></p>
<p><strong>vps系统OS：</strong>Ubuntu 18.04 LTS x64</p>
<p><strong>v2ray版本：</strong>4.45.2</p>
<p><strong>v2ray_util版本：</strong>3.10.9.6</p>
<p><strong>本地电脑：</strong>Mac</p>
</blockquote>
<h2 id="购买Vultr服务器"><a href="#购买Vultr服务器" class="headerlink" title="购买Vultr服务器"></a>购买Vultr服务器</h2><h3 id="注册Vultr"><a href="#注册Vultr" class="headerlink" title="注册Vultr"></a>注册Vultr</h3><p>点击<a href="https://www.vultr.com/?ref=9246988-8H">Vultr</a>进入注册页面,输入邮箱和密码创建账户</p>
<img data-src="/2022/10/07/vultr&v2ray_scientific_internet_access/1665113427866.jpg" class="">

<h3 id="充值10美元"><a href="#充值10美元" class="headerlink" title="充值10美元"></a>充值10美元</h3><p>这里支持选择支付宝付款，需要充值10美元才能开启部署服务器，可以看到右边的100美元的14天期限送的福利，充值后也就有110美元</p>
<img data-src="/2022/10/07/vultr&v2ray_scientific_internet_access/1665113926827.jpg" class="">

<h3 id="部署一台服务器"><a href="#部署一台服务器" class="headerlink" title="部署一台服务器"></a>部署一台服务器</h3><h4 id="选择2-5美元的服务器"><a href="#选择2-5美元的服务器" class="headerlink" title="选择2.5美元的服务器"></a>选择2.5美元的服务器</h4><p>这个是目前最便宜的了，我们基础的科学上网使用我这边个人使用来看是足够了</p>
<img data-src="/2022/10/07/vultr&v2ray_scientific_internet_access/1665123752800.jpg" class="">

<h4 id="服务器地址选择"><a href="#服务器地址选择" class="headerlink" title="服务器地址选择"></a>服务器地址选择</h4><p>这个我选择的New York（NJ）的服务器地址，这里你可以自己去随意挑选</p>
<img data-src="/2022/10/07/vultr&v2ray_scientific_internet_access/1665124128081.jpg" class="">

<h4 id="服务器系统选择"><a href="#服务器系统选择" class="headerlink" title="服务器系统选择"></a>服务器系统选择</h4><p>建议使用Ubuntu版本，后续的软件安装会搜索到资料比较广泛</p>
<img data-src="/2022/10/07/vultr&v2ray_scientific_internet_access/1665124271960.jpg" class="">

<h4 id="服务器磁盘大小选择"><a href="#服务器磁盘大小选择" class="headerlink" title="服务器磁盘大小选择"></a>服务器磁盘大小选择</h4><p>这个不同的大小价格会不同，我们不做巨大的数据量，我使用的3.5美元每月的就好了，这个可以带公网ipv4地址的功能会要多一美元，这个我要做连接服务器使用，2.5美元每月的只有ipv6地址（不然肯定选它..）</p>
<img data-src="/2022/10/07/vultr&v2ray_scientific_internet_access/1665124818267.jpg" class="">

<h4 id="去除服务器自动备份功能"><a href="#去除服务器自动备份功能" class="headerlink" title="去除服务器自动备份功能"></a>去除服务器自动备份功能</h4><p>这个功能会收取0.5美元每月的费用，我这边选择关闭此功能</p>
<img data-src="/2022/10/07/vultr&v2ray_scientific_internet_access/1665124523603.jpg" class="">

<h4 id="部署服务器"><a href="#部署服务器" class="headerlink" title="部署服务器"></a>部署服务器</h4><img data-src="/2022/10/07/vultr&v2ray_scientific_internet_access/1665125036525.jpg" class="">

<h4 id="查看服务器"><a href="#查看服务器" class="headerlink" title="查看服务器"></a>查看服务器</h4><img data-src="/2022/10/07/vultr&v2ray_scientific_internet_access/1665125133271.jpg" class="">
<p>点击服务器里面可以获取到我们的地址和服务器密码，后续在我们的本地电脑上通过IP和密码做ssh连接</p>
<img data-src="/2022/10/07/vultr&v2ray_scientific_internet_access/1665125278290.jpg" class="">


<h2 id="创建V2Ray服务端"><a href="#创建V2Ray服务端" class="headerlink" title="创建V2Ray服务端"></a>创建V2Ray服务端</h2><p>虚拟主机目前使用ssh的方式进行连接，如果是windows电脑百度使用Xshell工具软件进行连接vps使用，我使用的Mac电脑终端自带了ssh连接命令</p>
<h3 id="连接vps服务器"><a href="#连接vps服务器" class="headerlink" title="连接vps服务器"></a>连接vps服务器</h3><p>打开电脑终端输入：</p>
<div class="highlight-wrap" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">ssh root@104.156.225.196</span><br></pre></td></tr></table></figure></div>
<p>粘贴vps创建的服务器密码进行连接</p>
<img data-src="/2022/10/07/vultr&v2ray_scientific_internet_access/1665126021328.jpg" class="">
<p>连接成功显示</p>
<img data-src="/2022/10/07/vultr&v2ray_scientific_internet_access/1665128484391.jpg" class="">

<h3 id="一键部署V2ray服务器"><a href="#一键部署V2ray服务器" class="headerlink" title="一键部署V2ray服务器"></a>一键部署V2ray服务器</h3><h4 id="安装v2ray"><a href="#安装v2ray" class="headerlink" title="安装v2ray"></a>安装v2ray</h4><p>安装命令</p>
<div class="highlight-wrap" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">source</span> &lt;(curl -sL https://multi.netlify.app/v2ray.sh) --zh</span><br></pre></td></tr></table></figure></div>
<p>升级命令(保留配置文件更新)：</p>
<div class="highlight-wrap" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">source</span> &lt;(curl -sL https://multi.netlify.app/v2ray.sh) -k</span><br></pre></td></tr></table></figure></div>
<p>卸载命令：</p>
<div class="highlight-wrap" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">source</span> &lt;(curl -sL https://multi.netlify.app/v2ray.sh) --remove</span><br></pre></td></tr></table></figure></div>
<p>使用安装命令粘贴在终端执行，等待命令执行完毕，完成界面</p>
<img data-src="/2022/10/07/vultr&v2ray_scientific_internet_access/1665128956268.jpg" class="">
<p>执行v2ray修改协议为websocket</p>
<div style="width:50%;margin:auto"><img data-src="/2022/10/07/vultr&v2ray_scientific_internet_access/1665129461949.jpg" class=""></div>
修复<font color=red>v2ray restart fail !</font>错误，执行如下命令
<div class="highlight-wrap" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">sed -i <span class="string">&quot;s/v2ray -config/v2ray run -config/g&quot;</span> /etc/systemd/system/v2ray.service.d/10-donot_touch_single_conf.conf</span><br><span class="line">systemctl daemon-reload</span><br><span class="line">v2ray update v4.45.2</span><br><span class="line">systemctl restart v2ray</span><br></pre></td></tr></table></figure></div>
查看v2ray是否安装成功，出现这个表示已成功
<img data-src="/2022/10/07/vultr&v2ray_scientific_internet_access/1665129800018.jpg" class="">

<h4 id="检测v2ray端口外网是否可访问"><a href="#检测v2ray端口外网是否可访问" class="headerlink" title="检测v2ray端口外网是否可访问"></a>检测v2ray端口外网是否可访问</h4><ul>
<li><p>在vps连接终端查看端口信息<br><code>cat /etc/v2ray/config.json</code><br>在inbounds中可以看到v2ray服务器的端口信息，使用<a href="https://tool.chinaz.com/port">站长工具</a>检查一下IP和端口是可以访问的，如果不通的话需要关闭vps的防火墙配置</p>
</li>
<li><p>关闭防火墙</p>
</li>
</ul>
<p>安装firewalld: </p>
<div class="highlight-wrap" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">apt install firewalld</span><br></pre></td></tr></table></figure></div>
<p>停止firewall命令：</p>
<div class="highlight-wrap" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">systemctl stop firewalld.service</span><br></pre></td></tr></table></figure></div>
<p>禁止firewall开机启动命令：systemctl disable firewalld.service</p>
<div class="highlight-wrap" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">systemctl <span class="built_in">disable</span> firewalld.service</span><br></pre></td></tr></table></figure></div>
<h3 id="一键加速V2ray服务器"><a href="#一键加速V2ray服务器" class="headerlink" title="一键加速V2ray服务器"></a>一键加速V2ray服务器</h3><p>执行命令</p>
<div class="highlight-wrap" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">wget -N --no-check-certificate <span class="string">&quot;https://raw.githubusercontent.com/chiakge/Linux-NetSpeed/master/tcp.sh&quot;</span></span><br><span class="line"><span class="built_in">chmod</span> +x tcp.sh</span><br><span class="line">./tcp.sh</span><br></pre></td></tr></table></figure></div>
<h4 id="安装加速内核"><a href="#安装加速内核" class="headerlink" title="安装加速内核"></a>安装加速内核</h4><div style="width:50%;margin:auto"><img data-src="/2022/10/07/vultr&v2ray_scientific_internet_access/1665131802400.jpg" class=""></div>
#### 安装加速模块
<div style="width:50%;margin:auto"><img data-src="/2022/10/07/vultr&v2ray_scientific_internet_access/1665132000188.jpg" class=""></div>
如果出现这个选择no
<img data-src="/2022/10/07/vultr&v2ray_scientific_internet_access/1665131918313.jpg" class="">

<p>至此，服务端的配置全部完成，并且验证服务端没有啥问题</p>
<h2 id="客户端连接"><a href="#客户端连接" class="headerlink" title="客户端连接"></a>客户端连接</h2><p>客户端每个终端需要下载不同的软件进行连接使用</p>
<h3 id="Mac客户端连接v2ray服务器"><a href="#Mac客户端连接v2ray服务器" class="headerlink" title="Mac客户端连接v2ray服务器"></a>Mac客户端连接v2ray服务器</h3><p>Mac使用<a href="https://github.com/yanue/V2rayU/releases">V2rayU</a>软件进行连接<br>查看vps远程服务器配置文件</p>
<div style="width:50%;margin:auto"><img data-src="/2022/10/07/vultr&v2ray_scientific_internet_access/1665134205990.jpg" class=""></div>

<p>V2rayU配置<br>查看</p>
<div style="width:50%;margin:auto"><img data-src="/2022/10/07/vultr&v2ray_scientific_internet_access/1665134969825.jpg" class=""></div>

<p>打开浏览器查看是否成功，如果无法成功需要看v2rayU的日志再来看哪里出了问题</p>
<img data-src="/2022/10/07/vultr&v2ray_scientific_internet_access/1665135150951.jpg" class="">

<h3 id="Android客户端连接v2ray服务器"><a href="#Android客户端连接v2ray服务器" class="headerlink" title="Android客户端连接v2ray服务器"></a>Android客户端连接v2ray服务器</h3><p>Android使用<a href="https://apkpure.com/v2rayng/com.v2ray.ang/download">v2rayNG</a>软件进行连接<br>从上面的Mac桌面端配置文件中导出一个配置文件，放到手机的本地目录位置</p>
<img data-src="/2022/10/07/vultr&v2ray_scientific_internet_access/1665135748869.jpg" class="">
<p>选取上面倒入的配置文件</p>
<div style="width:50%;margin:auto"><img data-src="/2022/10/07/vultr&v2ray_scientific_internet_access/1665139835835.jpg" class=""></div>
<div style="width:50%;margin:auto"><img data-src="/2022/10/07/vultr&v2ray_scientific_internet_access/1665139985337.jpg" class=""></div>
倒入后连接如果失败从这里查看日志信息，我有遇到一个需要修改本地的inbounds里面的端口，修改成一个未被占用的即可，其他错误根据错误来处理
<div style="width:50%;margin:auto">]]></content>
      <categories>
        <category>网络</category>
      </categories>
      <tags>
        <tag>网络</tag>
        <tag>翻墙</tag>
      </tags>
  </entry>
</search>
